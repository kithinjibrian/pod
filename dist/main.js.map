{
  "version": 3,
  "sources": ["../src/main.ts", "../src/dev/server.ts", "../src/config/config.ts", "../src/plugins/index.ts", "../src/plugins/my.ts", "../src/macros/index.ts", "../src/macros/expand_macros.ts", "../src/macros/macro_executer.ts", "../src/store/index.ts", "../src/store/store.ts", "../src/plugins/generators/generate_controller.ts", "../src/plugins/generators/tsx_server_stub.ts", "../src/plugins/transformers/j2d.ts", "../src/plugins/generators/generate_server_component.ts", "../src/plugins/generators/generate_rsc.ts", "../src/plugins/analyzers/graph.ts", "../src/plugins/css/index.ts", "../src/config/index.ts", "../src/add/component/component.ts", "../src/utils/cases.ts", "../src/utils/create.ts", "../src/add/new/index.ts", "../src/add/module/module.ts", "../src/docker/docker.ts"],
  "sourcesContent": ["#!/usr/bin/env node\nimport { Command } from \"commander\";\nimport { startDevServer } from \"./dev\";\n\nimport * as store from \"./store\";\nexport { store };\n\nimport * as config from \"./config\";\nexport { config };\n\nexport * from \"./config/config\";\n\nimport * as macros from \"./macros\";\nexport { macros };\n\nexport * from \"./macros/expand_macros\";\n\nimport * as plugins from \"./plugins\";\nexport { plugins };\nexport * from \"./plugins/css\";\n\nimport { addComponent, addNew } from \"./add\";\nimport { addFeature } from \"./add/module\";\n\nimport path from \"path\";\nimport { execSync } from \"child_process\";\nimport { dockerize } from \"./docker\";\n\nconst program = new Command();\n\nprogram.name(\"pod\").description(\"Pod cli tool\").version(\"0.0.0\");\n\nprogram\n  .command(\"new <name>\")\n  .description(\"Start a new Pod Project\")\n  .action(async (name: string) => {\n    await addNew(name);\n\n    const appDir = path.resolve(process.cwd(), name);\n\n    console.log(\"Installing dependencies...\");\n    execSync(\"npm install\", { stdio: \"inherit\", cwd: appDir });\n\n    console.log(\"Starting development server...\");\n    execSync(\"npm run dev\", { stdio: \"inherit\", cwd: appDir });\n\n    console.log(`All done! Your app \"${name}\" is running in development mode.`);\n  });\n\nprogram\n  .command(\"dev\")\n  .description(\"Start Pod development server\")\n  .action(async (opts) => {\n    await startDevServer();\n  });\n\nprogram\n  .command(\"add <type> <name>\")\n  .description(\"Add a component (c) or a feature (f)\")\n  .action(async (type, name) => {\n    try {\n      if (type === \"c\") {\n        await addComponent(name);\n      } else if (type === \"f\") {\n        await addFeature(name);\n      } else {\n        console.error(\"\u274C Unknown type. Use 'c' or 'f'.\");\n      }\n    } catch (err: any) {\n      console.error(\"\u274C Error:\", err.message);\n    }\n  });\n\nprogram\n  .command(\"dockerize <env>\")\n  .description(\"Dockerize a pod project.\")\n  .action(async (env) => {\n    try {\n      await dockerize(env);\n    } catch (err: any) {\n      console.error(\"\u274C Error:\", err.message);\n    }\n  });\n\nprogram\n  .command(\"deploy <type> <options>\")\n  .description(\"Deploy a Pod Project\")\n  .action(async (type, name) => {\n    try {\n    } catch (err: any) {\n      console.error(\"\u274C Error:\", err.message);\n    }\n  });\n\nprogram.parse(process.argv);\n", "import * as esbuild from \"esbuild\";\nimport { spawn, ChildProcess } from \"child_process\";\nimport * as fs from \"fs/promises\";\nimport { loadConfig, mergeConfig, getDefaultConfig } from \"../config/config\";\nimport { buildGraph, useMyPlugin } from \"@/plugins\";\nimport { Store } from \"@/store\";\n\nasync function copyFile(): Promise<void> {\n  try {\n    await fs.mkdir(\"public\", { recursive: true });\n    await fs.copyFile(\"./src/client/index.html\", \"./public/index.html\");\n  } catch (error) {\n    console.error(\"\u274C Failed to copy index.html:\", error);\n    throw error;\n  }\n}\n\nasync function cleanDirectories(): Promise<void> {\n  await Promise.all([\n    fs.rm(\"dist\", { recursive: true, force: true }),\n    fs.rm(\"public\", { recursive: true, force: true }),\n  ]);\n}\n\nfunction createRestartServerPlugin(\n  serverProcess: { current: ChildProcess | null },\n  onServerBuildComplete: () => void\n): esbuild.Plugin {\n  return {\n    name: \"restart-server\",\n    setup(build) {\n      build.onEnd((result) => {\n        if (result.errors.length > 0) {\n          console.error(\n            `\u274C Server build failed with ${result.errors.length} error(s)`\n          );\n          return;\n        }\n\n        if (serverProcess.current) {\n          serverProcess.current.kill(\"SIGTERM\");\n        }\n\n        serverProcess.current = spawn(\"node\", [\"dist/main.js\"], {\n          stdio: \"inherit\",\n        });\n\n        serverProcess.current.on(\"error\", (err) => {\n          console.error(\"\u274C Server process error:\", err);\n        });\n\n        onServerBuildComplete();\n      });\n    },\n  };\n}\n\nexport async function startDevServer(): Promise<void> {\n  const store = Store.getInstance();\n  const userConfig = await loadConfig();\n  const config = mergeConfig(getDefaultConfig(), userConfig);\n\n  await cleanDirectories();\n  await copyFile();\n\n  const entryPoints = [\"src/main.ts\"];\n  const clientFiles = new Set<string>([\"src/client/client.tsx\"]);\n  const serverProcessRef = { current: null as ChildProcess | null };\n  let clientCtx: esbuild.BuildContext | null = null;\n  let isShuttingDown = false;\n\n  let pendingClientFiles = new Set<string>();\n  let needsClientRebuild = false;\n\n  async function rebuildClient(): Promise<void> {\n    if (isShuttingDown) return;\n\n    try {\n      if (clientCtx) {\n        await clientCtx.dispose();\n        clientCtx = null;\n      }\n\n      if (clientFiles.size === 0) return;\n\n      const entryPoints = Array.from(clientFiles);\n      const graph = buildGraph(entryPoints);\n\n      clientCtx = await esbuild.context({\n        entryPoints,\n        bundle: true,\n        outdir: \"public\",\n        outbase: \".\",\n        platform: \"browser\",\n        format: \"esm\",\n        sourcemap: config.build?.sourcemap ?? true,\n        splitting: true,\n        minify: config.build?.minify ?? false,\n        plugins: [\n          ...(config.plugins?.map((cb) => cb(store)) || []),\n          ...(config.client_plugins?.map((cb) => cb(store)) || []),\n          useMyPlugin({\n            graph,\n            isServerBuild: false,\n            onClientFound: () => {},\n          }),\n          {\n            name: \"client-build-logger\",\n            setup(build: any) {\n              build.onEnd((result: any) => {\n                if (result.errors.length > 0) {\n                  console.error(\n                    `\u274C Client build failed with ${result.errors.length} error(s)`\n                  );\n                }\n              });\n            },\n          },\n        ],\n        write: true,\n      });\n\n      await clientCtx.watch();\n      pendingClientFiles.clear();\n      needsClientRebuild = false;\n    } catch (error) {\n      console.error(\"\u274C Failed to rebuild client:\", error);\n      throw error;\n    }\n  }\n\n  async function onServerBuildComplete(): Promise<void> {\n    if (needsClientRebuild && pendingClientFiles.size > 0) {\n      await rebuildClient();\n    }\n  }\n\n  const serverCtx = await esbuild.context({\n    entryPoints,\n    bundle: true,\n    outdir: config.build?.outDir || \"dist\",\n    platform: \"node\",\n    format: \"esm\",\n    packages: \"external\",\n    sourcemap: config.build?.sourcemap ?? true,\n    minify: config.build?.minify ?? false,\n    plugins: [\n      ...(config.plugins?.map((cb) => cb(store)) || []),\n      useMyPlugin({\n        isServerBuild: true,\n        onClientFound: async (filePath) => {\n          const isNewFile = !clientFiles.has(filePath);\n\n          if (isNewFile) {\n            clientFiles.add(filePath);\n            pendingClientFiles.add(filePath);\n            needsClientRebuild = true;\n          }\n        },\n      }),\n      createRestartServerPlugin(serverProcessRef, onServerBuildComplete),\n    ],\n    write: true,\n  });\n\n  async function shutdown(): Promise<void> {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n\n    try {\n      if (serverProcessRef.current) {\n        serverProcessRef.current.kill(\"SIGTERM\");\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n\n      await serverCtx.dispose();\n      if (clientCtx) await clientCtx.dispose();\n\n      process.exit(0);\n    } catch (error) {\n      console.error(\"\u274C Error during shutdown:\", error);\n      process.exit(1);\n    }\n  }\n\n  process.on(\"SIGINT\", shutdown);\n  process.on(\"SIGTERM\", shutdown);\n\n  await serverCtx.watch();\n}\n", "import * as path from \"path\";\nimport { pathToFileURL } from \"url\";\nimport * as fs from \"fs/promises\";\nimport { Store } from \"@/store\";\nimport type { Plugin } from \"esbuild\";\n\nexport type PodPlugin = (store: Store) => Plugin;\n\nexport interface PodConfig {\n  name: string;\n  build?: {\n    outDir?: string;\n    sourcemap?: boolean;\n    minify?: boolean;\n  };\n  plugins?: Array<PodPlugin>;\n  client_plugins?: Array<PodPlugin>;\n  server_plugins?: Array<PodPlugin>;\n}\n\nconst CONFIG_FILES = [\n  \"pod.config.js\",\n  \"pod.config.mjs\",\n  \"pod.config.ts\",\n  \"pod.config.mts\",\n];\n\nexport async function loadConfig(\n  root: string = process.cwd()\n): Promise<PodConfig> {\n  for (const configFile of CONFIG_FILES) {\n    const configPath = path.resolve(root, configFile);\n\n    try {\n      await fs.access(configPath);\n\n      if (configFile.endsWith(\".ts\") || configFile.endsWith(\".mts\")) {\n        return await loadTsConfig(configPath);\n      }\n\n      return await loadJsConfig(configPath);\n    } catch (error) {\n      continue;\n    }\n  }\n\n  return getDefaultConfig();\n}\n\nasync function loadJsConfig(configPath: string): Promise<PodConfig> {\n  try {\n    const fileUrl = pathToFileURL(configPath).href;\n\n    const configModule = await import(`${fileUrl}?t=${Date.now()}`);\n\n    const config = configModule.default || configModule;\n\n    if (typeof config === \"function\") {\n      return await config();\n    }\n\n    return config;\n  } catch (error) {\n    console.error(`\u274C Failed to load config from ${configPath}:`, error);\n    throw error;\n  }\n}\n\nasync function loadTsConfig(configPath: string): Promise<PodConfig> {\n  try {\n    const esbuild = await import(\"esbuild\");\n\n    const result = await esbuild.build({\n      entryPoints: [configPath],\n      bundle: true,\n      platform: \"node\",\n      format: \"esm\",\n      write: false,\n      sourcemap: \"inline\",\n      packages: \"external\",\n    });\n\n    const tempFile = `${configPath}.${Date.now()}.mjs`;\n    await fs.writeFile(tempFile, result.outputFiles[0].text);\n\n    try {\n      const fileUrl = pathToFileURL(tempFile).href;\n\n      const configModule = await import(fileUrl);\n\n      const config = configModule.default || configModule;\n\n      if (typeof config === \"function\") {\n        return await config();\n      }\n\n      return config;\n    } finally {\n      await fs.unlink(tempFile).catch(() => {});\n    }\n  } catch (error) {\n    console.error(\n      `\u274C Failed to load TypeScript config from ${configPath}:`,\n      error\n    );\n    throw error;\n  }\n}\n\nexport function getDefaultConfig(): PodConfig {\n  return {\n    name: \"app\",\n    build: {\n      outDir: \"dist\",\n      sourcemap: true,\n      minify: false,\n    },\n    plugins: [],\n    client_plugins: [],\n    server_plugins: [],\n  };\n}\n\nexport function mergeConfig(\n  defaults: PodConfig,\n  userConfig: PodConfig\n): PodConfig {\n  return {\n    name: userConfig.name,\n    build: { ...defaults.build, ...userConfig.build },\n    plugins: [...(defaults.plugins || []), ...(userConfig.plugins || [])],\n    client_plugins: [\n      ...(defaults.client_plugins || []),\n      ...(userConfig.client_plugins || []),\n    ],\n    server_plugins: [\n      ...(defaults.server_plugins || []),\n      ...(userConfig.server_plugins || []),\n    ],\n  };\n}\n", "export * from \"./my\";\nexport * from \"./analyzers/graph\";\nexport * from \"./css\";\n", "import type { Plugin, OnLoadArgs, OnLoadResult } from \"esbuild\";\nimport * as fs from \"fs/promises\";\nimport { ReactConfig, transform } from \"@swc/core\";\nimport * as babel from \"@babel/core\";\nimport * as path from \"path\";\nimport { expandMacros } from \"@/macros\";\nimport { DependencyGraph, FileNode } from \"./analyzers/graph\";\nimport { generateController } from \"./generators/generate_controller\";\nimport { generateServerStub } from \"./generators/tsx_server_stub\";\nimport { j2d } from \"./transformers/j2d\";\nimport { generateServerComponent } from \"./generators/generate_server_component\";\nimport { generateRscStub } from \"./generators/generate_rsc\";\n\ninterface MyPluginParams {\n  isServerBuild: boolean;\n  graph?: DependencyGraph;\n  onClientFound: (path: string) => void;\n}\n\ntype FileDirective = \"interactive\" | \"public\" | null;\n\ninterface FileMetadata {\n  source: string;\n  path: string;\n  isTsx: boolean;\n  directive: FileDirective;\n  isPublicFile: boolean;\n  isInteractiveFile: boolean;\n}\n\nasync function swcTransform(\n  source: string,\n  pathStr: string,\n  tsx: boolean = false,\n  react?: ReactConfig\n): Promise<OnLoadResult> {\n  const resolveDir = path.dirname(pathStr);\n\n  const swcResult = await transform(source, {\n    filename: pathStr,\n    jsc: {\n      parser: {\n        syntax: \"typescript\",\n        tsx,\n        decorators: true,\n      },\n      transform: {\n        legacyDecorator: true,\n        decoratorMetadata: true,\n        react,\n      },\n      target: \"esnext\",\n    },\n    isModule: true,\n  });\n\n  return {\n    contents: swcResult.code,\n    loader: \"js\",\n    resolveDir,\n  };\n}\n\nfunction parseFileMetadata(source: string, path: string): FileMetadata {\n  const isTsx = path.endsWith(\".tsx\");\n  const isInteractiveFile =\n    source.startsWith('\"use interactive\"') ||\n    source.startsWith(\"'use interactive'\");\n  const isPublicFile =\n    source.startsWith('\"use public\"') || source.startsWith(\"'use public'\");\n\n  let directive: FileDirective = null;\n  if (isInteractiveFile) directive = \"interactive\";\n  else if (isPublicFile) directive = \"public\";\n\n  return {\n    source,\n    path,\n    isTsx,\n    directive,\n    isPublicFile,\n    isInteractiveFile,\n  };\n}\n\nclass ServerBuildTransformer {\n  async transformPublicFile(\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    const controllerCode = generateController(path, source);\n\n    if (controllerCode) {\n      source = `${source}\\n\\n${controllerCode}\\n`;\n    }\n\n    return swcTransform(source, path);\n  }\n\n  async transformRegularTypeScript(\n    source: string,\n    path: string,\n    isPublic: boolean\n  ): Promise<OnLoadResult> {\n    if (isPublic) {\n      return this.transformPublicFile(source, path);\n    }\n    return swcTransform(source, path);\n  }\n\n  async transformServerTsx(\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    return swcTransform(source, path, true, {\n      runtime: \"automatic\",\n      importSource: \"@kithinji/orca\",\n    });\n  }\n\n  async transformInteractiveTsxStub(\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    const stubSource = generateServerStub(path, source);\n    return swcTransform(stubSource, path);\n  }\n\n  async process(\n    metadata: FileMetadata,\n    onClientFound: (path: string) => void\n  ): Promise<OnLoadResult> {\n    const expandedSource = await expandMacros(metadata.source, metadata.path);\n\n    const expandedMetadata = { ...metadata, source: expandedSource };\n    const { source, path, isTsx, isInteractiveFile, isPublicFile } =\n      expandedMetadata;\n\n    if (isTsx) {\n      if (isInteractiveFile) {\n        onClientFound(path);\n        return this.transformInteractiveTsxStub(source, path);\n      }\n      return this.transformServerTsx(source, path);\n    }\n\n    return this.transformRegularTypeScript(source, path, isPublicFile);\n  }\n}\n\nclass ClientBuildTransformer {\n  async transformInteractiveTsx(\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    const swcResult = await swcTransform(source, path, true, {\n      runtime: \"preserve\",\n    });\n\n    const babelResult = await babel.transformAsync(\n      swcResult.contents as string,\n      {\n        filename: path,\n        sourceType: \"module\",\n        plugins: [j2d],\n        parserOpts: {\n          plugins: [\"jsx\"],\n        },\n        configFile: false,\n        babelrc: false,\n      }\n    );\n\n    return {\n      contents: babelResult?.code || \"\",\n      loader: \"js\",\n      resolveDir: swcResult.resolveDir,\n    };\n  }\n\n  async transformServerComponent(\n    node: FileNode,\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    const scSource = generateServerComponent(path, source);\n    return swcTransform(scSource, path);\n  }\n\n  async transformPublicFileRsc(\n    node: FileNode,\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    const stubSource = generateRscStub(path, source);\n    return swcTransform(stubSource, path);\n  }\n\n  async transformSharedCode(\n    source: string,\n    path: string\n  ): Promise<OnLoadResult> {\n    return swcTransform(source, path);\n  }\n\n  async process(node: FileNode, metadata: FileMetadata): Promise<OnLoadResult> {\n    const expandedSource = await expandMacros(metadata.source, metadata.path);\n\n    const expandedMetadata = { ...metadata, source: expandedSource };\n    const { source, path, isTsx, directive } = expandedMetadata;\n\n    if (isTsx) {\n      if (directive === \"interactive\") {\n        return this.transformInteractiveTsx(source, path);\n      } else if (directive === null) {\n        return this.transformServerComponent(node, source, path);\n      } else {\n        throw new Error(\n          `Unexpected directive \"${directive}\" for TSX file: ${path}`\n        );\n      }\n    }\n\n    if (directive === \"public\") {\n      return this.transformPublicFileRsc(node, source, path);\n    }\n\n    if (directive === null) {\n      return this.transformSharedCode(source, path);\n    }\n\n    return {\n      contents: source,\n      loader: isTsx ? \"tsx\" : \"ts\",\n    };\n  }\n}\n\nexport function useMyPlugin(options: MyPluginParams): Plugin {\n  const serverTransformer = new ServerBuildTransformer();\n  const clientTransformer = new ClientBuildTransformer();\n\n  return {\n    name: \"Orca\",\n    setup(build) {\n      build.onLoad(\n        { filter: /\\.tsx?$/ },\n        async (args: OnLoadArgs): Promise<OnLoadResult> => {\n          const source = await fs.readFile(args.path, \"utf8\");\n          const metadata = parseFileMetadata(source, args.path);\n\n          if (options.isServerBuild) {\n            return serverTransformer.process(metadata, options.onClientFound);\n          }\n\n          if (!options.graph) {\n            throw new Error(\n              \"Dependency graph is required for client build but was not provided\"\n            );\n          }\n\n          const node = options.graph[args.path];\n          if (!node) {\n            throw new Error(\n              `File node not found in dependency graph: ${args.path}`\n            );\n          }\n\n          return clientTransformer.process(node, metadata);\n        }\n      );\n    },\n  };\n}\n", "export * from \"./expand_macros\";\nexport * from \"./macro_executer\";\n", "import ts from \"typescript\";\nimport path from \"path\";\nimport Module from \"node:module\";\nimport { macroExecuter } from \"./macro_executer\";\nimport { Store } from \"@/store\";\n\nexport interface MacroContext {\n  node: ts.CallExpression;\n  sourceFile: ts.SourceFile;\n  ts: typeof ts;\n  factory: ts.NodeFactory;\n  store: Store;\n  graph: MacroDependencyGraph;\n  get program(): ts.Program;\n  get checker(): ts.TypeChecker;\n  error(msg: string): never;\n}\n\ninterface MacroNode {\n  key: string;\n  variableName: string;\n  node: ts.CallExpression;\n  sourceFile: ts.SourceFile;\n  filePath: string;\n  dependencies: Set<string>;\n  value: any;\n  astResult?: ts.Node;\n  computed: boolean;\n}\n\nclass MacroDependencyGraph {\n  private nodes = new Map<string, MacroNode>();\n  private projectRoot: string;\n  private typeChecker?: ts.TypeChecker;\n\n  constructor(projectRoot: string) {\n    this.projectRoot = projectRoot;\n  }\n\n  setTypeChecker(checker: ts.TypeChecker) {\n    this.typeChecker = checker;\n  }\n\n  createKey(sourceFile: ts.SourceFile, variableName: string): string {\n    const relativePath = path.relative(this.projectRoot, sourceFile.fileName);\n    const normalized = relativePath.replace(/\\\\/g, \"/\");\n    return `${normalized}:${variableName}`;\n  }\n\n  addNode(\n    key: string,\n    variableName: string,\n    node: ts.CallExpression,\n    sourceFile: ts.SourceFile\n  ) {\n    if (!this.nodes.has(key)) {\n      this.nodes.set(key, {\n        key,\n        variableName,\n        node,\n        sourceFile,\n        filePath: sourceFile.fileName,\n        dependencies: new Set(),\n        value: undefined,\n        computed: false,\n      });\n    }\n  }\n\n  getNode(key: string): MacroNode | undefined {\n    return this.nodes.get(key);\n  }\n\n  addDependency(fromKey: string, toKey: string) {\n    const node = this.nodes.get(fromKey);\n    if (node) {\n      node.dependencies.add(toKey);\n    }\n  }\n\n  setValue(key: string, value: any, astResult: ts.Node) {\n    const node = this.nodes.get(key);\n    if (node) {\n      node.value = value;\n      node.computed = true;\n      node.astResult = astResult;\n    }\n  }\n\n  getValue(key: string): any {\n    return this.nodes.get(key)?.value;\n  }\n\n  isComputed(key: string): boolean {\n    return this.nodes.get(key)?.computed ?? false;\n  }\n\n  topologicalSort(): string[] {\n    const visited = new Set<string>();\n    const inProgress = new Set<string>();\n    const sorted: string[] = [];\n\n    const visit = (key: string, path: string[] = []) => {\n      if (visited.has(key)) return;\n\n      if (inProgress.has(key)) {\n        const cycle = [...path, key].join(\" -> \");\n        throw new Error(`Circular macro dependency detected: ${cycle}`);\n      }\n\n      const node = this.nodes.get(key);\n      if (!node) return;\n\n      inProgress.add(key);\n\n      for (const depKey of node.dependencies) {\n        visit(depKey, [...path, key]);\n      }\n\n      inProgress.delete(key);\n      visited.add(key);\n      sorted.push(key);\n    };\n\n    for (const key of this.nodes.keys()) {\n      visit(key);\n    }\n\n    return sorted;\n  }\n\n  clear() {\n    this.nodes.clear();\n  }\n\n  getNodesForFile(filePath: string): MacroNode[] {\n    return Array.from(this.nodes.values()).filter(\n      (node) => node.filePath === filePath\n    );\n  }\n}\n\nlet globalGraph: MacroDependencyGraph | null = null;\n\nexport function getGlobalMacroGraph(projectRoot: string): MacroDependencyGraph {\n  if (!globalGraph) {\n    globalGraph = new MacroDependencyGraph(projectRoot);\n  }\n  return globalGraph;\n}\n\nexport function resetGlobalMacroGraph() {\n  globalGraph = null;\n}\n\nfunction resolveImportSpecifier(\n  importPath: string,\n  fromFile: string,\n  compilerOptions: ts.CompilerOptions\n): string | undefined {\n  const resolved = ts.resolveModuleName(\n    importPath,\n    fromFile,\n    compilerOptions,\n    ts.sys\n  );\n\n  if (resolved.resolvedModule?.resolvedFileName) {\n    return resolved.resolvedModule.resolvedFileName;\n  }\n\n  try {\n    const requireFromFile = Module.createRequire(fromFile);\n    return requireFromFile.resolve(importPath);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction resolveImportFullPath(\n  symbolName: string,\n  sourceFile: ts.SourceFile,\n  compilerOptions: ts.CompilerOptions\n): { importPath: string; resolvedPath: string | undefined } | undefined {\n  let importPath: string | undefined;\n\n  sourceFile.forEachChild((node) => {\n    if (!ts.isImportDeclaration(node) || !node.importClause) return;\n\n    const { namedBindings, name } = node.importClause;\n\n    if (name && name.text === symbolName) {\n      importPath = (node.moduleSpecifier as ts.StringLiteral).text;\n    }\n\n    if (namedBindings && ts.isNamedImports(namedBindings)) {\n      for (const specifier of namedBindings.elements) {\n        const importedName = specifier.name.text;\n        if (importedName === symbolName) {\n          importPath = (node.moduleSpecifier as ts.StringLiteral).text;\n        }\n      }\n    }\n\n    if (namedBindings && ts.isNamespaceImport(namedBindings)) {\n      if (symbolName.startsWith(namedBindings.name.text + \".\")) {\n        importPath = (node.moduleSpecifier as ts.StringLiteral).text;\n      }\n    }\n  });\n\n  if (!importPath) return undefined;\n\n  const resolvedPath = resolveImportSpecifier(\n    importPath,\n    sourceFile.fileName,\n    compilerOptions\n  );\n\n  return {\n    importPath: importPath.startsWith(\".\") ? resolvedPath! : importPath,\n    resolvedPath,\n  };\n}\n\nfunction isNpmPackage(importPath: string): boolean {\n  return (\n    !importPath.startsWith(\".\") &&\n    !importPath.startsWith(\"/\") &&\n    !path.isAbsolute(importPath)\n  );\n}\n\nfunction findVariableDeclarationInFile(\n  variableName: string,\n  sourceFile: ts.SourceFile\n): ts.VariableDeclaration | undefined {\n  let found: ts.VariableDeclaration | undefined;\n\n  function visit(node: ts.Node) {\n    if (found) return;\n\n    if (ts.isVariableDeclaration(node)) {\n      if (ts.isIdentifier(node.name) && node.name.text === variableName) {\n        found = node;\n        return;\n      }\n    }\n\n    ts.forEachChild(node, visit);\n  }\n\n  visit(sourceFile);\n  return found;\n}\n\nfunction createEvaluator(\n  graph: MacroDependencyGraph,\n  currentFileKey: string,\n  sourceFile: ts.SourceFile,\n  compilerOptions: ts.CompilerOptions\n) {\n  const trackedDependencies: string[] = [];\n\n  function evaluateArgumentValue(arg: ts.Expression): any {\n    if (ts.isStringLiteral(arg) || ts.isNoSubstitutionTemplateLiteral(arg)) {\n      return arg.text;\n    }\n    if (ts.isNumericLiteral(arg)) {\n      return Number(arg.text);\n    }\n    if (arg.kind === ts.SyntaxKind.TrueKeyword) return true;\n    if (arg.kind === ts.SyntaxKind.FalseKeyword) return false;\n    if (arg.kind === ts.SyntaxKind.NullKeyword) return null;\n    if (arg.kind === ts.SyntaxKind.UndefinedKeyword) return undefined;\n\n    if (ts.isTemplateExpression(arg)) {\n      let result = arg.head.text;\n      for (const span of arg.templateSpans) {\n        const exprValue = evaluateArgumentValue(span.expression);\n        result += String(exprValue) + span.literal.text;\n      }\n      return result;\n    }\n\n    if (ts.isObjectLiteralExpression(arg)) {\n      const obj: any = {};\n      for (const prop of arg.properties) {\n        if (ts.isPropertyAssignment(prop)) {\n          const key = ts.isIdentifier(prop.name)\n            ? prop.name.text\n            : ts.isStringLiteral(prop.name)\n            ? prop.name.text\n            : ts.isNumericLiteral(prop.name)\n            ? prop.name.text\n            : ts.isComputedPropertyName(prop.name)\n            ? evaluateArgumentValue(prop.name.expression)\n            : undefined;\n\n          if (key !== undefined) {\n            obj[key] = evaluateArgumentValue(prop.initializer);\n          }\n        } else if (ts.isShorthandPropertyAssignment(prop)) {\n          const name = prop.name.text;\n          obj[name] = resolveIdentifier(prop.name);\n        } else if (ts.isSpreadAssignment(prop)) {\n          const spread = evaluateArgumentValue(prop.expression);\n          Object.assign(obj, spread);\n        }\n      }\n      return obj;\n    }\n\n    if (ts.isArrayLiteralExpression(arg)) {\n      return arg.elements\n        .map((el) => {\n          if (ts.isSpreadElement(el)) {\n            const spread = evaluateArgumentValue(el.expression);\n            return Array.isArray(spread) ? spread : [spread];\n          }\n          return evaluateArgumentValue(el);\n        })\n        .flat();\n    }\n\n    if (ts.isPrefixUnaryExpression(arg)) {\n      const operand = evaluateArgumentValue(arg.operand);\n      switch (arg.operator) {\n        case ts.SyntaxKind.MinusToken:\n          return -operand;\n        case ts.SyntaxKind.PlusToken:\n          return +operand;\n        case ts.SyntaxKind.ExclamationToken:\n          return !operand;\n        case ts.SyntaxKind.TildeToken:\n          return ~operand;\n      }\n    }\n\n    if (ts.isBinaryExpression(arg)) {\n      const left = evaluateArgumentValue(arg.left);\n      const right = evaluateArgumentValue(arg.right);\n\n      switch (arg.operatorToken.kind) {\n        case ts.SyntaxKind.PlusToken:\n          return left + right;\n        case ts.SyntaxKind.MinusToken:\n          return left - right;\n        case ts.SyntaxKind.AsteriskToken:\n          return left * right;\n        case ts.SyntaxKind.SlashToken:\n          return left / right;\n        case ts.SyntaxKind.PercentToken:\n          return left % right;\n        case ts.SyntaxKind.AsteriskAsteriskToken:\n          return left ** right;\n        case ts.SyntaxKind.EqualsEqualsToken:\n          return left == right;\n        case ts.SyntaxKind.EqualsEqualsEqualsToken:\n          return left === right;\n        case ts.SyntaxKind.ExclamationEqualsToken:\n          return left != right;\n        case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n          return left !== right;\n        case ts.SyntaxKind.LessThanToken:\n          return left < right;\n        case ts.SyntaxKind.LessThanEqualsToken:\n          return left <= right;\n        case ts.SyntaxKind.GreaterThanToken:\n          return left > right;\n        case ts.SyntaxKind.GreaterThanEqualsToken:\n          return left >= right;\n        case ts.SyntaxKind.AmpersandAmpersandToken:\n          return left && right;\n        case ts.SyntaxKind.BarBarToken:\n          return left || right;\n        case ts.SyntaxKind.QuestionQuestionToken:\n          return left ?? right;\n      }\n    }\n\n    if (ts.isParenthesizedExpression(arg)) {\n      return evaluateArgumentValue(arg.expression);\n    }\n\n    if (ts.isConditionalExpression(arg)) {\n      const condition = evaluateArgumentValue(arg.condition);\n      return condition\n        ? evaluateArgumentValue(arg.whenTrue)\n        : evaluateArgumentValue(arg.whenFalse);\n    }\n\n    if (ts.isPropertyAccessExpression(arg)) {\n      const obj = evaluateArgumentValue(arg.expression);\n      const propName = arg.name.text;\n      return obj?.[propName];\n    }\n\n    if (ts.isElementAccessExpression(arg)) {\n      const obj = evaluateArgumentValue(arg.expression);\n      const index = evaluateArgumentValue(arg.argumentExpression);\n      return obj?.[index];\n    }\n\n    if (ts.isIdentifier(arg)) {\n      return resolveIdentifier(arg);\n    }\n\n    return arg.getText();\n  }\n\n  function resolveIdentifier(identifier: ts.Identifier): any {\n    const name = identifier.text;\n\n    const declaration = findVariableDeclarationInFile(name, sourceFile);\n\n    if (declaration && declaration.initializer) {\n      const varStatement = declaration.parent.parent as ts.VariableStatement;\n      const isConst = varStatement.declarationList.flags & ts.NodeFlags.Const;\n\n      if (!isConst) {\n        throw new Error(\n          `Macro argument '${name}' must be a const variable. let/var are not allowed.`\n        );\n      }\n\n      if (ts.isCallExpression(declaration.initializer)) {\n        const expr = declaration.initializer.expression;\n\n        if (ts.isIdentifier(expr) && expr.text.endsWith(\"$\")) {\n          const depKey = graph.createKey(sourceFile, name);\n\n          trackedDependencies.push(depKey);\n\n          const value = graph.getValue(depKey);\n\n          if (value !== undefined) {\n            return value;\n          }\n\n          throw new Error(\n            `Macro dependency '${name}' has not been computed yet. This should not happen.`\n          );\n        }\n      }\n\n      return evaluateArgumentValue(declaration.initializer);\n    }\n\n    const resolved = resolveImportFullPath(name, sourceFile, compilerOptions);\n\n    if (resolved) {\n      if (isNpmPackage(resolved.importPath)) {\n        throw new Error(\n          `Cannot resolve identifier '${name}' from npm package '${resolved.importPath}'. ` +\n            `Macro arguments from npm packages must be constants that can be evaluated at compile time.`\n        );\n      }\n\n      if (!resolved.resolvedPath) {\n        throw new Error(\n          `Could not resolve import path: ${resolved.importPath}`\n        );\n      }\n\n      const importedSource = ts.sys.readFile(resolved.resolvedPath);\n      if (!importedSource) {\n        throw new Error(\n          `Could not read imported file: ${resolved.resolvedPath}`\n        );\n      }\n\n      const importedSourceFile = ts.createSourceFile(\n        resolved.resolvedPath,\n        importedSource,\n        ts.ScriptTarget.Latest,\n        true\n      );\n\n      const importedDecl = findVariableDeclarationInFile(\n        name,\n        importedSourceFile\n      );\n\n      if (importedDecl && importedDecl.initializer) {\n        if (ts.isCallExpression(importedDecl.initializer)) {\n          const expr = importedDecl.initializer.expression;\n          if (ts.isIdentifier(expr) && expr.text.endsWith(\"$\")) {\n            const depKey = graph.createKey(importedSourceFile, name);\n            trackedDependencies.push(depKey);\n\n            const value = graph.getValue(depKey);\n            if (value !== undefined) {\n              return value;\n            }\n\n            throw new Error(\n              `Cross-file macro dependency '${name}' from '${resolved.resolvedPath}' needs to be computed first.`\n            );\n          }\n        }\n\n        const importedEvaluator = createEvaluator(\n          graph,\n          currentFileKey,\n          importedSourceFile,\n          compilerOptions\n        );\n        return importedEvaluator.evaluateArgumentValue(\n          importedDecl.initializer\n        );\n      }\n    }\n\n    throw new Error(\n      `Could not resolve identifier '${name}'. Make sure it's a const variable or imported constant.`\n    );\n  }\n\n  return {\n    evaluateArgumentValue,\n    getTrackedDependencies: () => trackedDependencies,\n  };\n}\n\nfunction extractValueFromASTNode(node: ts.Node): any {\n  if (ts.isStringLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node)) {\n    return node.text;\n  }\n  if (ts.isNumericLiteral(node)) return Number(node.text);\n  if (node.kind === ts.SyntaxKind.TrueKeyword) return true;\n  if (node.kind === ts.SyntaxKind.FalseKeyword) return false;\n  if (node.kind === ts.SyntaxKind.NullKeyword) return null;\n  if (node.kind === ts.SyntaxKind.UndefinedKeyword) return undefined;\n\n  if (ts.isObjectLiteralExpression(node)) {\n    const obj: any = {};\n    for (const prop of node.properties) {\n      if (ts.isPropertyAssignment(prop)) {\n        const key = ts.isIdentifier(prop.name)\n          ? prop.name.text\n          : ts.isStringLiteral(prop.name)\n          ? prop.name.text\n          : ts.isNumericLiteral(prop.name)\n          ? prop.name.text\n          : ts.isComputedPropertyName(prop.name)\n          ? extractValueFromASTNode(prop.name.expression)\n          : undefined;\n\n        if (key !== undefined) {\n          obj[key] = extractValueFromASTNode(prop.initializer);\n        }\n      } else if (ts.isShorthandPropertyAssignment(prop)) {\n        obj[prop.name.text] = prop.name.text;\n      } else if (ts.isSpreadAssignment(prop)) {\n        const spread = extractValueFromASTNode(prop.expression);\n        if (typeof spread === \"object\" && spread !== null) {\n          Object.assign(obj, spread);\n        }\n      }\n    }\n    return obj;\n  }\n}\n\nexport async function expandMacros(\n  source: string,\n  filePath: string,\n  projectRoot: string = process.cwd()\n): Promise<string> {\n  if (!source.includes(\"$(\") && !source.includes(\"$`\")) {\n    return source;\n  }\n\n  const compilerOptions: ts.CompilerOptions = {\n    module: ts.ModuleKind.ESNext,\n    target: ts.ScriptTarget.Latest,\n    moduleResolution: ts.ModuleResolutionKind.NodeNext,\n  };\n\n  const sourceFile = ts.createSourceFile(\n    filePath,\n    source,\n    ts.ScriptTarget.Latest,\n    true,\n    filePath.endsWith(\".tsx\") ? ts.ScriptKind.TSX : ts.ScriptKind.TS\n  );\n\n  const graph = getGlobalMacroGraph(projectRoot);\n\n  const getProgram = () =>\n    ts.createProgram([filePath], {\n      target: ts.ScriptTarget.ESNext,\n      module: ts.ModuleKind.ESNext,\n    });\n\n  const getTypeChecker = () => getProgram()?.getTypeChecker();\n\n  function discoverMacros(node: ts.Node) {\n    if (ts.isVariableDeclaration(node) && node.initializer) {\n      if (\n        ts.isCallExpression(node.initializer) &&\n        ts.isIdentifier(node.initializer.expression) &&\n        node.initializer.expression.text.endsWith(\"$\")\n      ) {\n        if (ts.isIdentifier(node.name)) {\n          const variableName = node.name.text;\n          const key = graph.createKey(sourceFile, variableName);\n          graph.addNode(key, variableName, node.initializer, sourceFile);\n        }\n      }\n    }\n    ts.forEachChild(node, discoverMacros);\n  }\n\n  discoverMacros(sourceFile);\n\n  const fileNodes = graph.getNodesForFile(filePath);\n\n  for (const macroNode of fileNodes) {\n    if (graph.isComputed(macroNode.key)) continue;\n\n    const evaluator = createEvaluator(\n      graph,\n      macroNode.key,\n      macroNode.sourceFile,\n      compilerOptions\n    );\n\n    try {\n      for (const arg of macroNode.node.arguments) {\n        evaluator.evaluateArgumentValue(arg);\n      }\n      const deps = evaluator.getTrackedDependencies();\n\n      for (const dep of deps) {\n        graph.addDependency(macroNode.key, dep);\n      }\n    } catch (e) {}\n  }\n\n  const sortedKeys = graph.topologicalSort();\n\n  for (const key of sortedKeys) {\n    const macroNode = graph.getNode(key);\n    if (!macroNode || graph.isComputed(key)) continue;\n\n    const node = macroNode.node;\n    const name = (node.expression as ts.Identifier).text;\n\n    const resolved = resolveImportFullPath(\n      name,\n      macroNode.sourceFile,\n      compilerOptions\n    );\n\n    if (!resolved) {\n      throw new Error(`Could not resolve macro import for '${name}'`);\n    }\n\n    const macro = macroExecuter().getMacro(resolved.importPath, name);\n\n    if (!macro) {\n      throw new Error(`Could not get macro '${name}' for key '${key}'`);\n    }\n\n    const macroContext: MacroContext = {\n      node,\n      sourceFile: macroNode.sourceFile,\n      ts,\n      store: Store.getInstance(),\n      factory: ts.factory,\n      graph,\n      get program() {\n        return getProgram();\n      },\n      get checker() {\n        return getTypeChecker();\n      },\n      error: (msg: string) => {\n        throw new Error(msg);\n      },\n    };\n\n    try {\n      const evaluator = createEvaluator(\n        graph,\n        key,\n        macroNode.sourceFile,\n        compilerOptions\n      );\n\n      const userArgs = node.arguments.map((arg) =>\n        evaluator.evaluateArgumentValue(arg)\n      );\n\n      const result = macro(...userArgs, macroContext);\n\n      if (!result || typeof result !== \"object\" || !(\"kind\" in result)) {\n        throw new Error(`Macro '${name}' must return a TypeScript AST node`);\n      }\n\n      const value = extractValueFromASTNode(result);\n\n      graph.setValue(key, value, result);\n    } catch (e: any) {\n      console.error(`Macro '${name}' execution failed: ${e?.message ?? e}`);\n      throw e;\n    }\n  }\n\n  const transformer: ts.TransformerFactory<ts.SourceFile> = (context) => {\n    const visit = (node: ts.Node): ts.Node => {\n      if (ts.isVariableDeclaration(node) && node.initializer) {\n        if (\n          ts.isCallExpression(node.initializer) &&\n          ts.isIdentifier(node.initializer.expression) &&\n          node.initializer.expression.text.endsWith(\"$\") &&\n          ts.isIdentifier(node.name)\n        ) {\n          const key = graph.createKey(sourceFile, node.name.text);\n          const macroNode = graph.getNode(key);\n\n          if (macroNode && graph.isComputed(key)) {\n            const result = graph.getNode(key)!;\n\n            return context.factory.updateVariableDeclaration(\n              node,\n              node.name,\n              node.exclamationToken,\n              node.type,\n              result.astResult as any\n            );\n          }\n        }\n      }\n\n      if (ts.isCallExpression(node) && ts.isIdentifier(node.expression)) {\n        const name = node.expression.text;\n\n        if (name.endsWith(\"$\")) {\n          const resolved = resolveImportFullPath(\n            name,\n            sourceFile,\n            compilerOptions\n          );\n\n          if (resolved) {\n            const macro = macroExecuter().getMacro(resolved.importPath, name);\n\n            if (macro) {\n              const macroContext: MacroContext = {\n                node,\n                sourceFile,\n                ts,\n                graph,\n                store: Store.getInstance(),\n                factory: context.factory,\n                get program() {\n                  return getProgram();\n                },\n                get checker() {\n                  return getTypeChecker();\n                },\n                error: (msg: string) => {\n                  throw new Error(msg);\n                },\n              };\n\n              try {\n                const tempKey = `${graph.createKey(sourceFile, \"__temp__\")}:${\n                  node.pos\n                }`;\n                const evaluator = createEvaluator(\n                  graph,\n                  tempKey,\n                  sourceFile,\n                  compilerOptions\n                );\n\n                const userArgs = node.arguments.map((arg) =>\n                  evaluator.evaluateArgumentValue(arg)\n                );\n\n                const result = macro(...userArgs, macroContext);\n\n                if (\n                  !result ||\n                  typeof result !== \"object\" ||\n                  !(\"kind\" in result)\n                ) {\n                  throw new Error(\n                    `Macro '${name}' must return a TypeScript AST node`\n                  );\n                }\n\n                return result;\n              } catch (e: any) {\n                console.log(\n                  `Macro '${name}' execution failed: ${e?.message ?? e}`\n                );\n                return node;\n              }\n            }\n          }\n        }\n      }\n\n      return ts.visitEachChild(node, visit, context);\n    };\n\n    return (sf) => ts.visitNode(sf, visit) as ts.SourceFile;\n  };\n\n  const result = ts.transform(sourceFile, [transformer]);\n  const output = ts.createPrinter().printFile(result.transformed[0]);\n  result.dispose();\n\n  return output;\n}\n", "import * as vm from \"node:vm\";\nimport * as esbuild from \"esbuild\";\nimport * as path from \"node:path\";\nimport Module from \"node:module\";\n\ntype MacroFunction = Function & { name: string };\n\ntype LoadedMacros = Record<string, MacroFunction>;\n\nexport class MacroExecutor {\n  private cache = new Map<string, LoadedMacros>();\n\n  getMacro(specifier: string, macroName?: string): MacroFunction {\n    if (!this.cache.has(specifier)) {\n      this.load(specifier);\n    }\n\n    const macros = this.cache.get(specifier)!;\n\n    if (macroName) {\n      const fn = macros[macroName];\n      if (!fn) {\n        throw new Error(`Macro \"${macroName}\" not found in ${specifier}`);\n      }\n      return fn;\n    }\n\n    const names = Object.keys(macros);\n\n    if (names.length === 1) {\n      return macros[names[0]];\n    }\n\n    if (macros.default) {\n      return macros.default;\n    }\n\n    throw new Error(`Multiple macros in ${specifier}: ${names.join(\", \")}`);\n  }\n\n  private load(specifier: string) {\n    const requireFromHere = Module.createRequire(\n      process.cwd() + \"/package.json\"\n    );\n\n    const entry = requireFromHere.resolve(specifier);\n\n    const { outputFiles } = esbuild.buildSync({\n      entryPoints: [entry],\n      bundle: true,\n      write: false,\n      platform: \"node\",\n      format: \"cjs\",\n      external: [...Module.builtinModules],\n    });\n\n    const code = outputFiles[0].text;\n\n    const sandboxRequire = Module.createRequire(entry);\n\n    const sandbox: any = {\n      module: { exports: {} },\n      exports: {},\n      require: sandboxRequire,\n      console,\n      __filename: entry,\n      __dirname: path.dirname(entry),\n      process,\n    };\n\n    sandbox.global = sandbox;\n\n    const context = vm.createContext(sandbox);\n    new vm.Script(code, { filename: entry }).runInContext(context);\n\n    const macros: LoadedMacros = {};\n    const exports = sandbox.module.exports;\n\n    console.log(exports);\n\n    for (const [name, value] of Object.entries(exports)) {\n      if (typeof value === \"function\" && name.endsWith(\"$\")) {\n        macros[name] = value;\n      }\n    }\n\n    if (!Object.keys(macros).length) {\n      throw new Error(`No macros found in ${specifier}`);\n    }\n\n    this.cache.set(specifier, macros);\n  }\n}\n\nconst macroExecutor = new MacroExecutor();\n\nexport function macroExecuter(): MacroExecutor {\n  return macroExecutor;\n}\n", "export * from \"./store\";\n", "export class Store {\n  private static instance: Store;\n  private containers: Map<string, unknown[]> = new Map();\n\n  private constructor() {}\n\n  public static getInstance(): Store {\n    if (!Store.instance) {\n      Store.instance = new Store();\n    }\n    return Store.instance;\n  }\n\n  public set<T>(key: string, value: T): void {\n    const existing = this.containers.get(key) || [];\n    existing.push(value);\n    this.containers.set(key, existing);\n  }\n\n  public get<T>(key: string): T[] | undefined {\n    const values = this.containers.get(key);\n    return values as T[] | undefined;\n  }\n\n  public has(key: string): boolean {\n    return this.containers.has(key);\n  }\n\n  public delete(key: string): boolean {\n    return this.containers.delete(key);\n  }\n\n  public clear(): void {\n    this.containers.clear();\n  }\n\n  public keys(): IterableIterator<string> {\n    return this.containers.keys();\n  }\n\n  public get size(): number {\n    return this.containers.size;\n  }\n}\n", "import * as path from \"path\";\nimport { parseSync } from \"@swc/core\";\nimport type {\n  ClassDeclaration,\n  Decorator,\n  Param,\n  ImportDeclaration,\n} from \"@swc/core\";\n\ninterface ServiceMethod {\n  name: string;\n  params: MethodParam[];\n  returnType: string;\n  isAsync: boolean;\n  paramSchemas: string[];\n  returnSchema?: string;\n}\n\ninterface MethodParam {\n  name: string;\n  type: string;\n  decorators: string[];\n}\n\ninterface ServiceInfo {\n  className: string;\n  methods: ServiceMethod[];\n  hasInjectable: boolean;\n  importMap: Record<string, string>;\n}\n\nexport function generateController(\n  filePath: string,\n  code: string\n): string | null {\n  const ast = parseSync(code, {\n    syntax: \"typescript\",\n    tsx: filePath.endsWith(\"x\"),\n    decorators: true,\n  });\n\n  const serviceInfo = extractServiceInfo(ast);\n  if (!serviceInfo || !serviceInfo.hasInjectable) return null;\n\n  return generateControllerCode(serviceInfo, filePath);\n}\n\nfunction extractServiceInfo(ast: any): ServiceInfo | null {\n  let serviceClass: ClassDeclaration | null = null;\n  let hasInjectable = false;\n  const importMap: Record<string, string> = {};\n\n  for (const item of ast.body) {\n    if (item.type === \"ImportDeclaration\") {\n      const decl = item as ImportDeclaration;\n      const source = decl.source.value;\n      decl.specifiers.forEach((spec) => {\n        if (\n          spec.type === \"ImportSpecifier\" ||\n          spec.type === \"ImportDefaultSpecifier\" ||\n          spec.type === \"ImportNamespaceSpecifier\"\n        ) {\n          importMap[spec.local.value] = source;\n        }\n      });\n    }\n\n    if (\n      item.type === \"ExportDeclaration\" &&\n      item.declaration.type === \"ClassDeclaration\"\n    ) {\n      const classDecl = item.declaration as ClassDeclaration;\n      if (hasInjectableDecorator(classDecl.decorators)) {\n        serviceClass = classDecl;\n        hasInjectable = true;\n      }\n    }\n  }\n\n  if (!serviceClass || !serviceClass.identifier) return null;\n\n  return {\n    className: serviceClass.identifier.value,\n    methods: extractMethods(serviceClass),\n    hasInjectable,\n    importMap,\n  };\n}\n\nfunction hasInjectableDecorator(decorators?: Decorator[]): boolean {\n  return (\n    decorators?.some((d) => {\n      const expr = d.expression;\n      return (\n        (expr.type === \"Identifier\" && expr.value === \"Injectable\") ||\n        (expr.type === \"CallExpression\" &&\n          expr.callee.type === \"Identifier\" &&\n          expr.callee.value === \"Injectable\")\n      );\n    }) ?? false\n  );\n}\n\nfunction extractMethods(classDecl: ClassDeclaration): ServiceMethod[] {\n  const methods: ServiceMethod[] = [];\n\n  for (const member of classDecl.body) {\n    if (member.type === \"ClassMethod\" && member.accessibility === \"public\") {\n      const method = member as any;\n      const methodName =\n        method.key.type === \"Identifier\" ? method.key.value : \"\";\n      if (!methodName) continue;\n\n      if (!method.function.async) {\n        throw new Error(\n          `Server action ${classDecl.identifier.value}.${methodName} must be async.`\n        );\n      }\n\n      const { paramSchemas, returnSchema } = extractSignature(\n        method.function.decorators,\n        method.function.params.length\n      );\n\n      methods.push({\n        name: methodName,\n        params: extractMethodParams(method.function.params),\n        returnType: extractReturnType(method.function.returnType),\n        isAsync: true,\n        paramSchemas,\n        returnSchema,\n      });\n    }\n  }\n  return methods;\n}\n\nfunction extractSignature(\n  decorators: Decorator[] | undefined,\n  paramCount: number\n) {\n  if (!decorators) return { paramSchemas: [] };\n\n  for (const decorator of decorators) {\n    const expr = decorator.expression;\n    if (\n      expr.type === \"CallExpression\" &&\n      expr.callee.type === \"Identifier\" &&\n      expr.callee.value === \"Signature\"\n    ) {\n      const args = expr.arguments;\n      if (args.length === 0) return { paramSchemas: [] };\n\n      const schemaStrings = args.map((arg) =>\n        stringifyExpression(arg.expression)\n      );\n\n      if (args.length === 1) {\n        return { paramSchemas: [], returnSchema: schemaStrings[0] };\n      }\n\n      return {\n        paramSchemas: schemaStrings.slice(0, -1),\n        returnSchema: schemaStrings[schemaStrings.length - 1],\n      };\n    }\n  }\n  return { paramSchemas: [] };\n}\n\nfunction stringifyExpression(expr: any): string {\n  if (expr.type === \"Identifier\") return expr.value;\n  if (expr.type === \"MemberExpression\") {\n    return `${stringifyExpression(expr.object)}.${expr.property.value || \"\"}`;\n  }\n  if (expr.type === \"CallExpression\") {\n    const args = expr.arguments\n      .map((a: any) => stringifyExpression(a.expression))\n      .join(\", \");\n    return `${stringifyExpression(expr.callee)}(${args})`;\n  }\n  return \"any\";\n}\n\nfunction extractMethodParams(params: Param[]): MethodParam[] {\n  return params.map((p) => {\n    const pat = (p as any).pat;\n    return {\n      name: pat.value,\n      type: pat.typeAnnotation\n        ? stringifyType(pat.typeAnnotation.typeAnnotation)\n        : \"any\",\n      decorators: [],\n    };\n  });\n}\n\nfunction extractReturnType(node: any): string {\n  if (!node?.typeAnnotation) return \"any\";\n  const type = node.typeAnnotation;\n  if (type.type === \"TsTypeReference\" && type.typeName.value === \"Promise\") {\n    return stringifyType(type.typeParams?.params[0]);\n  }\n  return stringifyType(type);\n}\n\nfunction stringifyType(node: any): string {\n  if (!node) return \"any\";\n  switch (node.type) {\n    case \"TsKeywordType\":\n      return node.kind;\n    case \"TsTypeReference\":\n      const base = node.typeName.value;\n      const args = node.typeParams\n        ? `<${node.typeParams.params.map(stringifyType).join(\", \")}>`\n        : \"\";\n      return base + args;\n    case \"TsArrayType\":\n      return `${stringifyType(node.elemType)}[]`;\n    default:\n      return \"any\";\n  }\n}\n\nfunction generateControllerCode(\n  serviceInfo: ServiceInfo,\n  filePath: string\n): string {\n  const serviceName = serviceInfo.className;\n  const controllerName = serviceName.replace(/Service$/, \"AutoController\");\n  const serviceImportPath = `./${path.basename(filePath).replace(/\\.ts$/, \"\")}`;\n\n  const importGroups = new Map<string, Set<string>>();\n\n  const registerIdentifier = (id: string) => {\n    const source = serviceInfo.importMap[id] || serviceImportPath;\n    if (!importGroups.has(source)) importGroups.set(source, new Set());\n    importGroups.get(source)!.add(id);\n  };\n\n  serviceInfo.methods.forEach((m) => {\n    [...m.paramSchemas, m.returnSchema].filter(Boolean).forEach((s) => {\n      const matches = s!.match(/[A-Z][a-zA-Z0-9]*/g); \n      matches?.forEach(registerIdentifier);\n      if (s!.includes(\"z.\")) registerIdentifier(\"z\"); \n    });\n  });\n\n  let importStrings = `import { Controller, Post, Get, Body } from \"@kithinji/orca\";\\n`;\n\n  importGroups.forEach((ids, source) => {\n    const filteredIds = Array.from(ids).filter((id) => id !== serviceName);\n    if (filteredIds.length > 0) {\n      importStrings += `\\nimport { ${filteredIds.join(\n        \", \"\n      )} } from \"${source}\";`;\n    }\n  });\n\n  const methods = serviceInfo.methods\n    .map((m) => {\n      const hasParams = m.params.length > 0;\n      const bodyParam = hasParams ? `@Body() body: any` : \"\";\n\n      let body = \"\";\n      if (hasParams) {\n        if (m.paramSchemas.length > 0) {\n          body += `    const b = typeof body === 'object' && body !== null ? body : {};\\n`;\n          m.params.forEach((p, i) => {\n            body += `    const ${p.name} = ${m.paramSchemas[i]}.parse(b.${p.name});\\n`;\n          });\n        } else {\n          body += `    const { ${m.params\n            .map((p) => p.name)\n            .join(\", \")} } = body;\\n`;\n        }\n      }\n\n      const callArgs = m.params.map((p) => p.name).join(\", \");\n      const serviceCall = `this.${\n        serviceName.charAt(0).toLowerCase() + serviceName.slice(1)\n      }.${m.name}(${callArgs})`;\n\n      if (m.returnSchema) {\n        body += `    const res = await ${serviceCall};\\n    return ${m.returnSchema}.parse(res);`;\n      } else {\n        body += `    return ${serviceCall};`;\n      }\n\n      return `  @${hasParams ? \"Post\" : \"Get\"}(\"${m.name}\")\\n  async ${\n        m.name\n      }(${bodyParam}): Promise<${m.returnType}> {\\n${body}\\n  }`;\n    })\n    .join(\"\\n\\n\");\n\n  return `${importStrings}\n\n@Controller(\"/${serviceName}\", {\n  providedIn: \"root\",\n})\nexport class ${controllerName} {\n  constructor(private readonly ${\n    serviceName.charAt(0).toLowerCase() + serviceName.slice(1)\n  }: ${serviceName}) {}\n\n${methods}\n}`;\n}\n", "import * as path from \"path\";\nimport { createHash } from \"crypto\";\nimport { parseSync, printSync } from \"@swc/core\";\nimport type {\n  ModuleItem,\n  ClassDeclaration,\n  Decorator,\n  ImportDeclaration,\n} from \"@swc/core\";\n\ninterface ClassStub {\n  name: string;\n  propsType: string;\n  decorators: string[];\n}\n\ninterface ImportMap {\n  [localName: string]: string;\n}\n\nexport function generateServerStub(filePath: string, code: string): string {\n  const hash = createHash(\"md5\").update(filePath).digest(\"hex\").slice(0, 8);\n  const relativeFromSrc = filePath.split(\"/src/\")[1];\n  const parsed = path.parse(relativeFromSrc);\n\n  const fileName = path.join(\"src\", parsed.dir, parsed.name);\n\n  const ast = parseSync(code, {\n    syntax: \"typescript\",\n    tsx: filePath.endsWith(\"x\"),\n    decorators: true,\n  });\n\n  const importMap: ImportMap = {};\n  for (const item of ast.body) {\n    if (item.type === \"ImportDeclaration\") {\n      const decl = item as ImportDeclaration;\n      for (const specifier of decl.specifiers ?? []) {\n        let localName: string;\n        if (specifier.type === \"ImportSpecifier\") {\n          localName = specifier.local.value;\n        } else if (specifier.type === \"ImportDefaultSpecifier\") {\n          localName = specifier.local.value;\n        } else {\n          continue;\n        }\n        importMap[localName] = decl.source.value;\n      }\n    }\n  }\n\n  const preservedNodes: ModuleItem[] = [];\n  const stubbedClasses: ClassStub[] = [];\n\n  for (const item of ast.body) {\n    let shouldStub = false;\n\n    if (\n      item.type === \"ExportDeclaration\" &&\n      item.declaration?.type === \"ClassDeclaration\"\n    ) {\n      const classDecl = item.declaration as ClassDeclaration;\n\n      if (hasComponentDecorator(classDecl.decorators)) {\n        shouldStub = true;\n        const stub = extractClassStub(classDecl);\n        if (stub) {\n          stubbedClasses.push(stub);\n        }\n      }\n    }\n\n    if (!shouldStub) {\n      preservedNodes.push(item);\n    }\n  }\n\n  const preservedCode =\n    preservedNodes.length > 0\n      ? printSync({\n          type: \"Module\",\n          span: ast.span,\n          body: preservedNodes,\n          interpreter: ast.interpreter,\n        }).code\n      : \"\";\n\n  const stubCode = stubbedClasses\n    .map((stub) => generateClassCode(stub, hash, fileName))\n    .join(\"\\n\\n\");\n\n  return `\n${preservedCode}\n${stubCode}\n  `.trim();\n}\n\nfunction hasComponentDecorator(decorators?: Decorator[]): boolean {\n  if (!decorators) return false;\n  return decorators.some((decorator) => {\n    const expr = decorator.expression;\n    if (expr.type === \"Identifier\" && expr.value === \"Component\") {\n      return true;\n    }\n    if (\n      expr.type === \"CallExpression\" &&\n      expr.callee.type === \"Identifier\" &&\n      expr.callee.value === \"Component\"\n    ) {\n      return true;\n    }\n    return false;\n  });\n}\n\nfunction extractClassStub(classDecl: ClassDeclaration): ClassStub | null {\n  const className = classDecl.identifier?.value;\n  if (!className) return null;\n\n  let propsType = \"{}\";\n  const decorators: string[] = [];\n\n  if (classDecl.decorators) {\n    for (const dec of classDecl.decorators) {\n      const str = stringifyDecorator(dec);\n      if (str) decorators.push(str);\n    }\n  }\n\n  for (const member of classDecl.body) {\n    if (member.type === \"ClassProperty\") {\n      if (member.key.type === \"Identifier\" && member.key.value === \"props\") {\n        propsType = extractPropsType(member);\n      }\n    }\n  }\n\n  return {\n    name: className,\n    propsType,\n    decorators,\n  };\n}\n\nfunction stringifyDecorator(decorator: Decorator): string {\n  const expr = decorator.expression;\n  if (expr.type === \"CallExpression\" && expr.callee.type === \"Identifier\") {\n    return `@${expr.callee.value}()`;\n  }\n  if (expr.type === \"Identifier\") {\n    return `@${expr.value}`;\n  }\n  return \"\";\n}\n\nfunction extractPropsType(member: any): string {\n  const typeAnn = member.typeAnnotation?.typeAnnotation;\n  if (!typeAnn) return \"{}\";\n\n  if (typeAnn.type === \"TsTypeLiteral\") {\n    const props: string[] = [];\n    for (const m of typeAnn.members) {\n      if (m.type === \"TsPropertySignature\") {\n        const key = m.key.type === \"Identifier\" ? m.key.value : \"?\";\n        const t = m.typeAnnotation\n          ? stringifyType(m.typeAnnotation.typeAnnotation)\n          : \"any\";\n        props.push(`${key}: ${t}`);\n      }\n    }\n    return `{ ${props.join(\"; \")} }`;\n  }\n\n  return stringifyType(typeAnn);\n}\n\nfunction stringifyParam(param: any): string {\n  let decorators: string[] = [];\n  if (param.decorators) {\n    for (const d of param.decorators) {\n      const str = stringifyDecorator(d);\n      if (str) decorators.push(str);\n    }\n  }\n  const decoratorPrefix = decorators.length ? decorators.join(\" \") + \" \" : \"\";\n\n  let typeName = \"any\";\n  let paramName = \"\";\n  let accessibility = \"\";\n\n  if (param.type === \"TsParameterProperty\") {\n    accessibility = param.accessibility || \"\";\n    const inner = param.param;\n    if (inner.type !== \"Identifier\") return \"\";\n\n    paramName = inner.value;\n    if (inner.typeAnnotation?.typeAnnotation) {\n      typeName = extractTypeName(inner.typeAnnotation.typeAnnotation);\n    }\n  } else if (param.type === \"Parameter\") {\n    const pat = param.pat;\n    if (pat.type !== \"Identifier\") return \"\";\n\n    paramName = pat.value;\n    if (pat.typeAnnotation?.typeAnnotation) {\n      typeName = extractTypeName(pat.typeAnnotation.typeAnnotation);\n    }\n  } else {\n    return \"\";\n  }\n\n  const accessPrefix = accessibility ? `${accessibility} ` : \"\";\n  const result = `${decoratorPrefix}${accessPrefix}${paramName}: ${typeName}`;\n\n  return result;\n}\n\nfunction extractTypeName(typeNode: any): string {\n  if (\n    typeNode.type === \"TsTypeReference\" &&\n    typeNode.typeName.type === \"Identifier\"\n  ) {\n    return typeNode.typeName.value;\n  }\n  return stringifyType(typeNode);\n}\n\nfunction stringifyType(typeNode: any): string {\n  if (!typeNode) return \"any\";\n\n  switch (typeNode.type) {\n    case \"TsKeywordType\":\n      return typeNode.kind;\n    case \"TsTypeReference\":\n      if (typeNode.typeName.type === \"Identifier\")\n        return typeNode.typeName.value;\n      if (typeNode.typeName.type === \"TsQualifiedName\") {\n        return `${stringifyQualifiedName(typeNode.typeName.left)}.${\n          typeNode.typeName.right.value\n        }`;\n      }\n      return \"any\";\n    case \"TsArrayType\":\n      return `${stringifyType(typeNode.elemType)}[]`;\n    case \"TsUnionType\":\n      return typeNode.types.map(stringifyType).join(\" | \");\n    case \"TsIntersectionType\":\n      return typeNode.types.map(stringifyType).join(\" & \");\n    default:\n      return \"any\";\n  }\n}\n\nfunction stringifyQualifiedName(node: any): string {\n  if (node.type === \"Identifier\") return node.value;\n  if (node.type === \"TsQualifiedName\") {\n    return `${stringifyQualifiedName(node.left)}.${node.right.value}`;\n  }\n  return \"any\";\n}\n\nfunction generateClassCode(\n  stub: ClassStub,\n  hash: string,\n  fileName: string\n): string {\n  const clientId = `${stub.name}_${hash}`;\n  const clientPath = `/${fileName}.js`;\n  const decoratorsStr =\n    stub.decorators.length > 0 ? stub.decorators.join(\"\\n\") + \"\\n\" : \"\";\n\n  return `\n${decoratorsStr}export class ${stub.name} {\n  props!: ${stub.propsType};\n  constructor() {}\n  build() {\n    const inputProps = { ...this.props };\n    return {\n      $$typeof: Symbol.for(\"orca.client.component\"),\n      id: \"${clientId}_\" + Math.random().toString(36).slice(2, 9),\n      type: \"${stub.name}\",\n      props: {\n        ...inputProps,\n        __clientComponent: {\n          id: \"${clientId}\",\n          path: \"${clientPath}\",\n          name: \"${stub.name}\",\n        }\n      },\n      key: null\n    };\n  }\n}\n`.trim();\n}\n", "import type { PluginObj, NodePath } from \"@babel/core\";\nimport * as BabelTypes from \"@babel/types\";\n\ninterface PluginContext {\n  types: typeof BabelTypes;\n}\n\ninterface PluginState {\n  helpersImported?: boolean;\n}\n\ninterface TransformContext {\n  observables: Map<string, BabelTypes.Expression>;\n  observableSignals: Map<string, BabelTypes.Identifier>;\n}\n\ninterface TransformResult {\n  id: BabelTypes.Identifier;\n  statements: BabelTypes.Statement[];\n}\n\nclass NodeTypeGuards {\n  constructor(private t: typeof BabelTypes) {}\n\n  isSignalMember(expr: BabelTypes.Node): expr is BabelTypes.MemberExpression {\n    return (\n      this.t.isMemberExpression(expr) &&\n      this.t.isIdentifier(expr.property, { name: \"value\" })\n    );\n  }\n\n  isObservableMember(\n    expr: BabelTypes.Node\n  ): expr is BabelTypes.MemberExpression {\n    return (\n      this.t.isMemberExpression(expr) &&\n      this.t.isIdentifier(expr.property, { name: \"$value\" })\n    );\n  }\n}\n\nclass ASTUtilities {\n  constructor(private t: typeof BabelTypes, private guards: NodeTypeGuards) {}\n\n  getObject(expr: BabelTypes.Expression): BabelTypes.Expression {\n    if (\n      this.guards.isSignalMember(expr) ||\n      this.guards.isObservableMember(expr)\n    ) {\n      return expr.object as BabelTypes.Expression;\n    }\n    return expr;\n  }\n\n  replaceThisWithSelf<T extends BabelTypes.Node>(node: T): T {\n    const cloned = this.t.cloneNode(node, true) as T;\n    this.walkAndTransform(cloned, (n: any) => {\n      if (this.t.isThisExpression(n)) {\n        Object.assign(n, this.t.identifier(\"self\"));\n      }\n    });\n    return cloned;\n  }\n\n  private walkAndTransform(node: any, transform: (node: any) => void): void {\n    if (!node || typeof node !== \"object\") return;\n\n    transform(node);\n\n    for (const key in node) {\n      if (this.shouldSkipKey(key)) continue;\n\n      const value = node[key];\n      if (Array.isArray(value)) {\n        value.forEach((item) => this.walkAndTransform(item, transform));\n      } else if (value && typeof value === \"object\") {\n        this.walkAndTransform(value, transform);\n      }\n    }\n  }\n\n  private shouldSkipKey(key: string): boolean {\n    return [\"loc\", \"start\", \"end\", \"extra\"].includes(key);\n  }\n\n  buildMemberExpression(name: string): BabelTypes.Expression {\n    const parts = name.split(\".\");\n    let expr: BabelTypes.Expression = this.t.identifier(parts[0]);\n    for (let i = 1; i < parts.length; i++) {\n      expr = this.t.memberExpression(expr, this.t.identifier(parts[i]));\n    }\n    return expr;\n  }\n\n  insertBeforeReturn(\n    body: BabelTypes.Statement[],\n    statements: BabelTypes.Statement[]\n  ): void {\n    const returnIndex = body.findIndex((stmt) =>\n      this.t.isReturnStatement(stmt)\n    );\n    if (returnIndex !== -1) {\n      body.splice(returnIndex, 0, ...statements);\n    } else {\n      body.push(...statements);\n    }\n  }\n}\n\nclass JSXUtilities {\n  constructor(private t: typeof BabelTypes) {}\n\n  getComponentName(\n    nameNode:\n      | BabelTypes.JSXIdentifier\n      | BabelTypes.JSXMemberExpression\n      | BabelTypes.JSXNamespacedName\n  ): string | null {\n    if (this.t.isJSXIdentifier(nameNode)) {\n      return nameNode.name;\n    }\n\n    if (this.t.isJSXMemberExpression(nameNode)) {\n      const parts: string[] = [];\n      let current: BabelTypes.JSXMemberExpression | BabelTypes.JSXIdentifier =\n        nameNode;\n\n      while (this.t.isJSXMemberExpression(current)) {\n        parts.unshift(current.property.name);\n        current = current.object;\n      }\n\n      if (this.t.isJSXIdentifier(current)) {\n        parts.unshift(current.name);\n      }\n\n      return parts.join(\".\");\n    }\n\n    return null;\n  }\n\n  isComponentTag(tag: string | null): boolean {\n    return tag ? /^[A-Z]/.test(tag) : false;\n  }\n}\n\nclass ObservableManager {\n  constructor(private t: typeof BabelTypes, private guards: NodeTypeGuards) {}\n\n  getObservableKey(expr: BabelTypes.Node): string {\n    return this.stringifyNode(expr);\n  }\n\n  private stringifyNode(node: any): string {\n    if (!node) return \"\";\n    if (this.t.isThisExpression(node)) return \"this\";\n    if (this.t.isIdentifier(node)) return node.name;\n\n    if (this.t.isMemberExpression(node)) {\n      const obj = this.stringifyNode(node.object);\n      const prop = node.computed\n        ? `[${this.stringifyNode(node.property)}]`\n        : `.${(node.property as BabelTypes.Identifier).name}`;\n      return obj + prop;\n    }\n\n    if (this.t.isCallExpression(node)) {\n      const callee = this.stringifyNode(node.callee);\n      const args = node.arguments\n        .map((arg) => this.stringifyNode(arg))\n        .join(\",\");\n      return `${callee}(${args})`;\n    }\n\n    if (this.t.isStringLiteral(node)) return `\"${node.value}\"`;\n    if (this.t.isNumericLiteral(node)) return String(node.value);\n\n    return node.type + JSON.stringify(node.name || node.value || \"\");\n  }\n\n  collectObservables(\n    node: BabelTypes.Node,\n    observables: Map<string, BabelTypes.Expression>,\n    astUtils: ASTUtilities\n  ): void {\n    this.walkNode(node, (n: any) => {\n      if (this.guards.isObservableMember(n)) {\n        const observable = astUtils.replaceThisWithSelf(\n          n.object as BabelTypes.Expression\n        );\n        const key = this.getObservableKey(observable);\n        if (!observables.has(key)) {\n          observables.set(key, observable);\n        }\n      }\n    });\n  }\n\n  replaceObservablesWithSignals<T extends BabelTypes.Node>(\n    node: T,\n    observableSignals: Map<string, BabelTypes.Identifier>,\n    astUtils: ASTUtilities\n  ): T {\n    const cloned = this.t.cloneNode(node, true) as T;\n\n    this.walkNode(cloned, (n: any) => {\n      if (this.guards.isObservableMember(n)) {\n        const observable = astUtils.replaceThisWithSelf(n.object);\n        const key = this.getObservableKey(observable);\n        const signalId = observableSignals.get(key);\n\n        if (signalId) {\n          n.object = signalId;\n          n.property = this.t.identifier(\"value\");\n        }\n      }\n    });\n\n    return cloned;\n  }\n\n  private walkNode(node: any, callback: (node: any) => void): void {\n    if (!node || typeof node !== \"object\") return;\n\n    callback(node);\n\n    for (const key in node) {\n      if ([\"loc\", \"start\", \"end\", \"extra\"].includes(key)) continue;\n\n      const value = node[key];\n      if (Array.isArray(value)) {\n        value.forEach((item) => this.walkNode(item, callback));\n      } else if (value && typeof value === \"object\") {\n        this.walkNode(value, callback);\n      }\n    }\n  }\n}\n\nclass ElementTransformer {\n  constructor(\n    private t: typeof BabelTypes,\n    private guards: NodeTypeGuards,\n    private astUtils: ASTUtilities,\n    private jsxUtils: JSXUtilities,\n    private observableManager: ObservableManager\n  ) {}\n\n  transformElement(\n    path: { node: BabelTypes.JSXElement | BabelTypes.JSXFragment },\n    scope: any,\n    context: TransformContext\n  ): TransformResult {\n    if (this.t.isJSXFragment(path.node)) {\n      return this.transformFragment(\n        path as { node: BabelTypes.JSXFragment },\n        scope,\n        context\n      );\n    }\n    return this.transformJSXElement(\n      path as { node: BabelTypes.JSXElement },\n      scope,\n      context\n    );\n  }\n\n  private transformJSXElement(\n    path: { node: BabelTypes.JSXElement },\n    scope: any,\n    context: TransformContext\n  ): TransformResult {\n    const jsxElement = path.node;\n    const tag = this.jsxUtils.getComponentName(jsxElement.openingElement.name);\n    const isComponent = this.jsxUtils.isComponentTag(tag);\n\n    if (isComponent && tag) {\n      return this.transformComponentElement(jsxElement, tag, scope, context);\n    } else if (tag) {\n      return this.transformDOMElement(jsxElement, tag, scope, context);\n    }\n\n    return {\n      id: scope.generateUidIdentifier(\"el\"),\n      statements: [],\n    };\n  }\n\n  private transformComponentElement(\n    jsxElement: BabelTypes.JSXElement,\n    tag: string,\n    scope: any,\n    context: TransformContext\n  ): TransformResult {\n    const elId = scope.generateUidIdentifier(\"el\");\n    const statements: BabelTypes.Statement[] = [];\n    const props: Array<\n      | BabelTypes.ObjectProperty\n      | BabelTypes.ObjectMethod\n      | BabelTypes.SpreadElement\n    > = [];\n    const children: Array<BabelTypes.Expression> = [];\n\n    this.processComponentAttributes(\n      jsxElement.openingElement.attributes,\n      props,\n      context\n    );\n\n    this.processChildren(\n      jsxElement.children,\n      children,\n      statements,\n      scope,\n      context\n    );\n\n    if (children.length > 0) {\n      props.push(\n        this.t.objectProperty(\n          this.t.identifier(\"children\"),\n          children.length === 1 ? children[0] : this.t.arrayExpression(children)\n        )\n      );\n    }\n\n    statements.push(\n      this.t.variableDeclaration(\"var\", [\n        this.t.variableDeclarator(\n          elId,\n          this.t.callExpression(this.t.identifier(\"$createComponent\"), [\n            this.astUtils.buildMemberExpression(tag),\n            this.t.objectExpression(props),\n            this.t.identifier(\"self\"),\n          ])\n        ),\n      ])\n    );\n\n    return { id: elId, statements };\n  }\n\n  private transformDOMElement(\n    jsxElement: BabelTypes.JSXElement,\n    tag: string,\n    scope: any,\n    context: TransformContext\n  ): TransformResult {\n    const elId = scope.generateUidIdentifier(\"el\");\n    const statements: BabelTypes.Statement[] = [];\n\n    statements.push(\n      this.t.variableDeclaration(\"var\", [\n        this.t.variableDeclarator(\n          elId,\n          this.t.callExpression(\n            this.t.memberExpression(\n              this.t.identifier(\"document\"),\n              this.t.identifier(\"createElement\")\n            ),\n            [this.t.stringLiteral(tag)]\n          )\n        ),\n      ])\n    );\n\n    const { hasRef, refValue, hasDangerousHTML, dangerousHTMLValue } =\n      this.processDOMAttributes(\n        jsxElement.openingElement.attributes,\n        elId,\n        statements,\n        context\n      );\n\n    if (hasRef && refValue) {\n      statements.push(\n        this.t.expressionStatement(\n          this.t.assignmentExpression(\"=\", refValue as BabelTypes.LVal, elId)\n        )\n      );\n    }\n\n    if (hasDangerousHTML && dangerousHTMLValue) {\n      statements.push(\n        this.t.expressionStatement(\n          this.t.assignmentExpression(\n            \"=\",\n            this.t.memberExpression(elId, this.t.identifier(\"innerHTML\")),\n            this.t.memberExpression(\n              dangerousHTMLValue,\n              this.t.identifier(\"__html\")\n            )\n          )\n        )\n      );\n    }\n\n    if (!hasDangerousHTML) {\n      this.processDOMChildren(\n        jsxElement.children,\n        elId,\n        statements,\n        scope,\n        context\n      );\n    }\n\n    return { id: elId, statements };\n  }\n\n  private transformFragment(\n    path: { node: BabelTypes.JSXFragment },\n    scope: any,\n    context: TransformContext\n  ): TransformResult {\n    const fragId = scope.generateUidIdentifier(\"frag\");\n    const statements: BabelTypes.Statement[] = [];\n\n    statements.push(\n      this.t.variableDeclaration(\"var\", [\n        this.t.variableDeclarator(\n          fragId,\n          this.t.callExpression(\n            this.t.memberExpression(\n              this.t.identifier(\"document\"),\n              this.t.identifier(\"createDocumentFragment\")\n            ),\n            []\n          )\n        ),\n      ])\n    );\n\n    this.processDOMChildren(\n      path.node.children,\n      fragId,\n      statements,\n      scope,\n      context\n    );\n\n    return { id: fragId, statements };\n  }\n\n  private processComponentAttributes(\n    attributes: Array<BabelTypes.JSXAttribute | BabelTypes.JSXSpreadAttribute>,\n    props: Array<\n      | BabelTypes.ObjectProperty\n      | BabelTypes.ObjectMethod\n      | BabelTypes.SpreadElement\n    >,\n    context: TransformContext\n  ): void {\n    for (const attr of attributes) {\n      if (this.t.isJSXSpreadAttribute(attr)) {\n        this.observableManager.collectObservables(\n          attr.argument,\n          context.observables,\n          this.astUtils\n        );\n        const replaced = this.observableManager.replaceObservablesWithSignals(\n          attr.argument,\n          context.observableSignals,\n          this.astUtils\n        );\n        props.push(\n          this.t.spreadElement(this.astUtils.replaceThisWithSelf(replaced))\n        );\n        continue;\n      }\n\n      const key = (attr.name as BabelTypes.JSXIdentifier).name;\n\n      if (this.t.isStringLiteral(attr.value)) {\n        props.push(this.t.objectProperty(this.t.identifier(key), attr.value));\n      } else if (this.t.isJSXExpressionContainer(attr.value)) {\n        const expr = attr.value.expression as BabelTypes.Expression;\n        this.observableManager.collectObservables(\n          expr,\n          context.observables,\n          this.astUtils\n        );\n\n        if (\n          this.guards.isSignalMember(expr) ||\n          this.guards.isObservableMember(expr)\n        ) {\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            expr,\n            context.observableSignals,\n            this.astUtils\n          );\n          props.push(\n            this.t.objectMethod(\n              \"get\",\n              this.t.identifier(key),\n              [],\n              this.t.blockStatement([\n                this.t.returnStatement(\n                  this.astUtils.replaceThisWithSelf(replaced)\n                ),\n              ])\n            )\n          );\n        } else {\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            expr,\n            context.observableSignals,\n            this.astUtils\n          );\n          props.push(\n            this.t.objectProperty(\n              this.t.identifier(key),\n              this.astUtils.replaceThisWithSelf(replaced)\n            )\n          );\n        }\n      } else {\n        props.push(\n          this.t.objectProperty(\n            this.t.identifier(key),\n            this.t.booleanLiteral(true)\n          )\n        );\n      }\n    }\n  }\n\n  private processDOMAttributes(\n    attributes: Array<BabelTypes.JSXAttribute | BabelTypes.JSXSpreadAttribute>,\n    elId: BabelTypes.Identifier,\n    statements: BabelTypes.Statement[],\n    context: TransformContext\n  ): {\n    hasRef: boolean;\n    refValue: BabelTypes.Expression | null;\n    hasDangerousHTML: boolean;\n    dangerousHTMLValue: BabelTypes.Expression | null;\n  } {\n    let hasRef = false;\n    let refValue: BabelTypes.Expression | null = null;\n    let hasDangerousHTML = false;\n    let dangerousHTMLValue: BabelTypes.Expression | null = null;\n\n    for (const attr of attributes) {\n      if (this.t.isJSXSpreadAttribute(attr)) {\n        this.observableManager.collectObservables(\n          attr.argument,\n          context.observables,\n          this.astUtils\n        );\n        const replaced = this.observableManager.replaceObservablesWithSignals(\n          attr.argument,\n          context.observableSignals,\n          this.astUtils\n        );\n        statements.push(\n          this.t.expressionStatement(\n            this.t.callExpression(this.t.identifier(\"$spread\"), [\n              elId,\n              this.astUtils.replaceThisWithSelf(replaced),\n            ])\n          )\n        );\n        continue;\n      }\n\n      const key = (attr.name as BabelTypes.JSXIdentifier).name;\n\n      if (key === \"ref\") {\n        hasRef = true;\n        if (this.t.isJSXExpressionContainer(attr.value)) {\n          this.observableManager.collectObservables(\n            attr.value.expression,\n            context.observables,\n            this.astUtils\n          );\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            attr.value.expression as BabelTypes.Expression,\n            context.observableSignals,\n            this.astUtils\n          );\n          refValue = this.astUtils.replaceThisWithSelf(replaced);\n        }\n        continue;\n      }\n\n      if (key === \"dangerouslySetInnerHTML\") {\n        hasDangerousHTML = true;\n        if (this.t.isJSXExpressionContainer(attr.value)) {\n          this.observableManager.collectObservables(\n            attr.value.expression,\n            context.observables,\n            this.astUtils\n          );\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            attr.value.expression as BabelTypes.Expression,\n            context.observableSignals,\n            this.astUtils\n          );\n          dangerousHTMLValue = this.astUtils.replaceThisWithSelf(replaced);\n        }\n        continue;\n      }\n\n      if (/^on[A-Z]/.test(key)) {\n        this.processEventListener(key, attr, elId, statements, context);\n        continue;\n      }\n\n      if (key === \"style\" && this.t.isJSXExpressionContainer(attr.value)) {\n        this.processStyleAttribute(attr, elId, statements, context);\n        continue;\n      }\n\n      this.processRegularAttribute(key, attr, elId, statements, context);\n    }\n\n    return { hasRef, refValue, hasDangerousHTML, dangerousHTMLValue };\n  }\n\n  private processEventListener(\n    key: string,\n    attr: BabelTypes.JSXAttribute,\n    elId: BabelTypes.Identifier,\n    statements: BabelTypes.Statement[],\n    context: TransformContext\n  ): void {\n    const eventName = key.slice(2).toLowerCase();\n    let handler: BabelTypes.Expression = this.t.nullLiteral();\n\n    if (this.t.isJSXExpressionContainer(attr.value)) {\n      this.observableManager.collectObservables(\n        attr.value.expression,\n        context.observables,\n        this.astUtils\n      );\n      const replaced = this.observableManager.replaceObservablesWithSignals(\n        attr.value.expression as BabelTypes.Expression,\n        context.observableSignals,\n        this.astUtils\n      );\n      handler = this.astUtils.replaceThisWithSelf(replaced);\n    }\n\n    statements.push(\n      this.t.expressionStatement(\n        this.t.callExpression(\n          this.t.memberExpression(elId, this.t.identifier(\"addEventListener\")),\n          [this.t.stringLiteral(eventName), handler]\n        )\n      )\n    );\n  }\n\n  private processStyleAttribute(\n    attr: BabelTypes.JSXAttribute,\n    elId: BabelTypes.Identifier,\n    statements: BabelTypes.Statement[],\n    context: TransformContext\n  ): void {\n    if (!this.t.isJSXExpressionContainer(attr.value)) return;\n\n    this.observableManager.collectObservables(\n      attr.value.expression,\n      context.observables,\n      this.astUtils\n    );\n    const replaced = this.observableManager.replaceObservablesWithSignals(\n      attr.value.expression as BabelTypes.Expression,\n      context.observableSignals,\n      this.astUtils\n    );\n    statements.push(\n      this.t.expressionStatement(\n        this.t.callExpression(this.t.identifier(\"$style\"), [\n          elId,\n          this.t.arrowFunctionExpression(\n            [],\n            this.astUtils.replaceThisWithSelf(replaced)\n          ),\n        ])\n      )\n    );\n  }\n\n  private processRegularAttribute(\n    key: string,\n    attr: BabelTypes.JSXAttribute,\n    elId: BabelTypes.Identifier,\n    statements: BabelTypes.Statement[],\n    context: TransformContext\n  ): void {\n    const attrName = key === \"className\" ? \"class\" : key;\n    let value: BabelTypes.Expression;\n\n    if (this.t.isStringLiteral(attr.value)) {\n      value = attr.value;\n    } else if (this.t.isJSXExpressionContainer(attr.value)) {\n      this.observableManager.collectObservables(\n        attr.value.expression,\n        context.observables,\n        this.astUtils\n      );\n      const replaced = this.observableManager.replaceObservablesWithSignals(\n        attr.value.expression as BabelTypes.Expression,\n        context.observableSignals,\n        this.astUtils\n      );\n      value = this.astUtils.replaceThisWithSelf(replaced);\n    } else {\n      value = this.t.booleanLiteral(true);\n    }\n\n    statements.push(\n      this.t.expressionStatement(\n        this.t.callExpression(\n          this.t.memberExpression(elId, this.t.identifier(\"setAttribute\")),\n          [this.t.stringLiteral(attrName), value]\n        )\n      )\n    );\n  }\n\n  private processChildren(\n    children: Array<\n      | BabelTypes.JSXText\n      | BabelTypes.JSXExpressionContainer\n      | BabelTypes.JSXElement\n      | BabelTypes.JSXFragment\n      | BabelTypes.JSXSpreadChild\n    >,\n    childExpressions: Array<BabelTypes.Expression>,\n    statements: BabelTypes.Statement[],\n    scope: any,\n    context: TransformContext\n  ): void {\n    for (const child of children) {\n      if (this.t.isJSXText(child)) {\n        const text = child.value.trim();\n        if (text) childExpressions.push(this.t.stringLiteral(text));\n      } else if (this.t.isJSXExpressionContainer(child)) {\n        const expr = child.expression;\n        if (!this.t.isJSXEmptyExpression(expr)) {\n          this.observableManager.collectObservables(\n            expr,\n            context.observables,\n            this.astUtils\n          );\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            expr as BabelTypes.Expression,\n            context.observableSignals,\n            this.astUtils\n          );\n          childExpressions.push(this.astUtils.replaceThisWithSelf(replaced));\n        }\n      } else if (this.t.isJSXElement(child) || this.t.isJSXFragment(child)) {\n        const childEl = this.transformElement({ node: child }, scope, context);\n        statements.push(...childEl.statements);\n        childExpressions.push(childEl.id);\n      }\n    }\n  }\n\n  private processDOMChildren(\n    children: Array<\n      | BabelTypes.JSXText\n      | BabelTypes.JSXExpressionContainer\n      | BabelTypes.JSXElement\n      | BabelTypes.JSXFragment\n      | BabelTypes.JSXSpreadChild\n    >,\n    parentId: BabelTypes.Identifier,\n    statements: BabelTypes.Statement[],\n    scope: any,\n    context: TransformContext\n  ): void {\n    for (const child of children) {\n      if (this.t.isJSXText(child)) {\n        const text = child.value.trim();\n        if (!text) continue;\n        statements.push(\n          this.t.expressionStatement(\n            this.t.callExpression(this.t.identifier(\"$insert\"), [\n              parentId,\n              this.t.stringLiteral(text),\n            ])\n          )\n        );\n      } else if (this.t.isJSXExpressionContainer(child)) {\n        const expr = child.expression;\n        if (this.t.isJSXEmptyExpression(expr)) continue;\n\n        this.observableManager.collectObservables(\n          expr,\n          context.observables,\n          this.astUtils\n        );\n\n        let insertedValue: BabelTypes.Expression;\n        if (this.guards.isSignalMember(expr)) {\n          insertedValue = this.astUtils.getObject(\n            expr as BabelTypes.Expression\n          );\n        } else if (this.guards.isObservableMember(expr)) {\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            expr as BabelTypes.Expression,\n            context.observableSignals,\n            this.astUtils\n          );\n          insertedValue = this.astUtils.getObject(replaced);\n        } else {\n          const replaced = this.observableManager.replaceObservablesWithSignals(\n            expr as BabelTypes.Expression,\n            context.observableSignals,\n            this.astUtils\n          );\n          insertedValue = this.t.arrowFunctionExpression(\n            [],\n            this.astUtils.replaceThisWithSelf(replaced)\n          );\n        }\n\n        statements.push(\n          this.t.expressionStatement(\n            this.t.callExpression(this.t.identifier(\"$insert\"), [\n              parentId,\n              insertedValue,\n            ])\n          )\n        );\n      } else if (this.t.isJSXElement(child) || this.t.isJSXFragment(child)) {\n        const childEl = this.transformElement({ node: child }, scope, context);\n        statements.push(...childEl.statements);\n        statements.push(\n          this.t.expressionStatement(\n            this.t.callExpression(this.t.identifier(\"$insert\"), [\n              parentId,\n              childEl.id,\n            ])\n          )\n        );\n      }\n    }\n  }\n}\n\nexport function j2d({ types: t }: PluginContext): PluginObj<PluginState> {\n  const guards = new NodeTypeGuards(t);\n  const astUtils = new ASTUtilities(t, guards);\n  const jsxUtils = new JSXUtilities(t);\n  const observableManager = new ObservableManager(t, guards);\n  const elementTransformer = new ElementTransformer(\n    t,\n    guards,\n    astUtils,\n    jsxUtils,\n    observableManager\n  );\n\n  return {\n    name: \"jsx-to-dom\",\n    visitor: {\n      Program: {\n        exit(path: NodePath<BabelTypes.Program>, state: PluginState) {\n          if (state.helpersImported) return;\n\n          const helpers = [\n            { local: \"$insert\", imported: \"insert\" },\n            { local: \"$createComponent\", imported: \"createComponent\" },\n            { local: \"$style\", imported: \"style\" },\n            { local: \"$spread\", imported: \"spread\" },\n            { local: \"$toSignal\", imported: \"toSignal\" },\n          ];\n\n          for (const helper of helpers) {\n            path.unshiftContainer(\n              \"body\",\n              t.importDeclaration(\n                [\n                  t.importSpecifier(\n                    t.identifier(helper.local),\n                    t.identifier(helper.imported)\n                  ),\n                ],\n                t.stringLiteral(\"@kithinji/orca\")\n              )\n            );\n          }\n\n          state.helpersImported = true;\n        },\n      },\n\n      ClassMethod(path: NodePath<BabelTypes.ClassMethod>) {\n        if (path.getData(\"processed\")) return;\n\n        // Check if method contains JSX\n        let hasJSX = false;\n        path.traverse({\n          JSXElement() {\n            hasJSX = true;\n          },\n          JSXFragment() {\n            hasJSX = true;\n          },\n        });\n\n        if (!hasJSX) return;\n        path.setData(\"processed\", true);\n\n        const body = path.node.body;\n        if (!t.isBlockStatement(body)) return;\n\n        // Collect all observables from JSX\n        const observables = new Map<string, BabelTypes.Expression>();\n        path.traverse({\n          JSXElement(jsxPath: NodePath<BabelTypes.JSXElement>) {\n            observableManager.collectObservables(\n              jsxPath.node,\n              observables,\n              astUtils\n            );\n          },\n          JSXFragment(jsxPath: NodePath<BabelTypes.JSXFragment>) {\n            observableManager.collectObservables(\n              jsxPath.node,\n              observables,\n              astUtils\n            );\n          },\n        });\n\n        // Add self reference\n        body.body.unshift(\n          t.variableDeclaration(\"const\", [\n            t.variableDeclarator(t.identifier(\"self\"), t.thisExpression()),\n          ])\n        );\n\n        // Create signal declarations for observables\n        const observableSignals = new Map<string, BabelTypes.Identifier>();\n        const signalDeclarations: BabelTypes.Statement[] = [];\n\n        for (const [key, observable] of observables) {\n          const signalId = path.scope.generateUidIdentifier(\"sig\");\n          observableSignals.set(key, signalId);\n          signalDeclarations.push(\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(\n                signalId,\n                t.callExpression(t.identifier(\"$toSignal\"), [\n                  observable,\n                  t.identifier(\"self\"),\n                ])\n              ),\n            ])\n          );\n        }\n\n        if (signalDeclarations.length > 0) {\n          astUtils.insertBeforeReturn(body.body, signalDeclarations);\n        }\n\n        const context: TransformContext = { observables, observableSignals };\n\n        // Transform JSX elements and fragments\n        path.traverse({\n          JSXElement(jsxPath: NodePath<BabelTypes.JSXElement>) {\n            if (jsxPath.getData(\"processed\")) return;\n            jsxPath.setData(\"processed\", true);\n\n            const { id, statements } = elementTransformer.transformElement(\n              jsxPath as any,\n              jsxPath.scope,\n              context\n            );\n\n            jsxPath.replaceWith(\n              t.callExpression(\n                t.arrowFunctionExpression(\n                  [],\n                  t.blockStatement([...statements, t.returnStatement(id)])\n                ),\n                []\n              )\n            );\n          },\n          JSXFragment(jsxPath: NodePath<BabelTypes.JSXFragment>) {\n            if (jsxPath.getData(\"processed\")) return;\n            jsxPath.setData(\"processed\", true);\n\n            const { id, statements } = elementTransformer.transformElement(\n              jsxPath as any,\n              jsxPath.scope,\n              context\n            );\n\n            jsxPath.replaceWith(\n              t.callExpression(\n                t.arrowFunctionExpression(\n                  [],\n                  t.blockStatement([...statements, t.returnStatement(id)])\n                ),\n                []\n              )\n            );\n          },\n        });\n      },\n    },\n  };\n}\n", "import { parseSync } from \"@swc/core\";\nimport type { ClassDeclaration, Decorator } from \"@swc/core\";\n\ninterface MethodParam {\n  name: string;\n  type: string;\n}\n\ninterface ComponentMethod {\n  name: string;\n  params: MethodParam[];\n  returnType: string;\n  isAsync: boolean;\n}\n\ninterface ComponentInfo {\n  className: string;\n  methods: ComponentMethod[];\n}\n\nexport function generateServerComponent(\n  filePath: string,\n  code: string\n): string {\n  const ast = parseSync(code, {\n    syntax: \"typescript\",\n    tsx: filePath.endsWith(\"x\"),\n    decorators: true,\n  });\n\n  const componentInfo = extractComponentInfo(ast);\n\n  return generateStubCode(componentInfo);\n}\n\nfunction extractComponentInfo(ast: any): ComponentInfo {\n  let componentClass: ClassDeclaration | null = null;\n\n  for (const item of ast.body) {\n    if (\n      item.type === \"ExportDeclaration\" &&\n      item.declaration.type === \"ClassDeclaration\"\n    ) {\n      const classDecl = item.declaration as ClassDeclaration;\n\n      if (hasComponentDecorator(classDecl.decorators)) {\n        componentClass = classDecl;\n        break;\n      }\n    }\n  }\n\n  if (!componentClass || !componentClass.identifier) {\n    throw new Error(\"Component class is undefined\");\n  }\n\n  const className = componentClass.identifier.value;\n  const methods = extractMethods(componentClass);\n\n  return {\n    className,\n    methods,\n  };\n}\n\nfunction hasComponentDecorator(decorators?: Decorator[]): boolean {\n  if (!decorators) return false;\n\n  return decorators.some((decorator) => {\n    const expr = decorator.expression;\n\n    if (expr.type === \"CallExpression\") {\n      if (\n        expr.callee.type === \"Identifier\" &&\n        expr.callee.value === \"Component\"\n      ) {\n        return true;\n      }\n    }\n\n    if (expr.type === \"Identifier\" && expr.value === \"Component\") {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction extractMethods(classDecl: ClassDeclaration): ComponentMethod[] {\n  const methods: ComponentMethod[] = [];\n\n  for (const member of classDecl.body) {\n    if (member.type === \"ClassMethod\") {\n      const method = member as any;\n\n      const methodName =\n        method.key.type === \"Identifier\" ? method.key.value : \"\";\n\n      if (!methodName) {\n        continue;\n      }\n\n      const params = extractMethodParams(method.function.params || []);\n      const returnType = extractReturnType(method.function.returnType);\n      const isAsync = method.function.async || false;\n\n      methods.push({\n        name: methodName,\n        params,\n        returnType,\n        isAsync,\n      });\n    }\n  }\n\n  return methods;\n}\n\nfunction extractMethodParams(params: any[]): MethodParam[] {\n  const result: MethodParam[] = [];\n\n  for (const param of params) {\n    if (param.type === \"Parameter\") {\n      const pat = param.pat as any;\n\n      if (pat.type === \"Identifier\") {\n        const name = pat.value;\n        const type = pat.typeAnnotation?.typeAnnotation\n          ? stringifyType(pat.typeAnnotation.typeAnnotation)\n          : \"any\";\n\n        result.push({\n          name,\n          type,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction extractReturnType(returnType?: any): string {\n  if (!returnType || !returnType.typeAnnotation) {\n    return \"any\";\n  }\n\n  const type = returnType.typeAnnotation;\n\n  if (type.type === \"TsTypeReference\") {\n    const typeName = type.typeName;\n    if (typeName.type === \"Identifier\" && typeName.value === \"Promise\") {\n      if (type.typeParams && type.typeParams.params.length > 0) {\n        return stringifyType(type.typeParams.params[0]);\n      }\n    }\n  }\n\n  return stringifyType(type);\n}\n\nfunction stringifyType(typeNode: any): string {\n  if (!typeNode) return \"any\";\n\n  switch (typeNode.type) {\n    case \"TsKeywordType\":\n      return typeNode.kind;\n\n    case \"TsTypeReference\":\n      if (typeNode.typeName.type === \"Identifier\") {\n        const baseName = typeNode.typeName.value;\n        if (typeNode.typeParams && typeNode.typeParams.params.length > 0) {\n          const params = typeNode.typeParams.params\n            .map(stringifyType)\n            .join(\", \");\n          return `${baseName}<${params}>`;\n        }\n        return baseName;\n      }\n      return \"any\";\n\n    case \"TsArrayType\":\n      return `${stringifyType(typeNode.elemType)}[]`;\n\n    case \"TsUnionType\":\n      return typeNode.types.map(stringifyType).join(\" | \");\n\n    case \"TsIntersectionType\":\n      return typeNode.types.map(stringifyType).join(\" & \");\n\n    case \"TsTypeLiteral\":\n      const props = typeNode.members\n        .map((member: any) => {\n          if (member.type === \"TsPropertySignature\") {\n            const key =\n              member.key.type === \"Identifier\" ? member.key.value : \"\";\n            const type = member.typeAnnotation\n              ? stringifyType(member.typeAnnotation.typeAnnotation)\n              : \"any\";\n            return `${key}: ${type}`;\n          }\n          return \"\";\n        })\n        .filter(Boolean);\n      return `{ ${props.join(\"; \")} }`;\n\n    default:\n      return \"any\";\n  }\n}\n\nfunction generateStubCode(componentInfo: ComponentInfo): string {\n  const className = componentInfo.className;\n\n  const build = componentInfo.methods.find((p) => p.name == \"build\");\n\n  if (build == undefined) {\n    throw new Error(\"Component has no build function\");\n  }\n\n  return `import { \n  Component, \n  Inject, \n  getCurrentInjector, \n  OrcaComponent,\n  JSX,\n  OSC,\n  HttpClient,\n} from \"@kithinji/orca\";\n\n@Component()\nexport class ${className} extends OrcaComponent {\n    props!: any;\n\n    constructor(\n      @Inject(\"OSC_URL\", { maybe: true }) private oscUrl?: string,\n      private readonly http: HttpClient,\n    ) {\n      super();\n\n      if(this.oscUrl === undefined) {\n        throw new Error(\"Server component requires osc url be defined\");\n      }  \n    }\n\n    build() {\n        const root = document.createElement(\"div\");\n        root.textContent = \"loading...\";\n\n        const injector = getCurrentInjector();\n\n        if(injector == null) {\n          throw new Error(\"Injector is null\");\n        }\n\n        const osc = new OSC(root);\n\n        const subscription = this.http.post<JSX.Element>(\n          \\`\\${this.oscUrl}?c=${className}\\`, {\n            body: this.props\n          }\n        ).subscribe((jsx: JSX.Element) => {\n          const action = jsx.action || \"insert\";\n\n          if (action === \"insert\") {\n            osc.handleInsert(jsx);\n          } else if (action === \"update\") {\n            osc.handleUpdate(jsx);\n          } else {\n            console.warn(\\`Unknown action: \\${action}\\`);\n          }\n        });\n\n        this.pushDrop(() => subscription.unsubscribe());\n\n        return root;\n    }\n}`;\n}\n", "import { parseSync } from \"@swc/core\";\nimport type { ClassDeclaration, Decorator } from \"@swc/core\";\n\ninterface ServiceMethod {\n  name: string;\n  params: MethodParam[];\n  returnType: string;\n  isAsync: boolean;\n}\n\ninterface MethodParam {\n  name: string;\n  type: string;\n}\n\ninterface ServiceInfo {\n  className: string;\n  methods: ServiceMethod[];\n}\n\nexport function generateRscStub(filePath: string, code: string): string {\n  const ast = parseSync(code, {\n    syntax: \"typescript\",\n    tsx: filePath.endsWith(\"x\"),\n    decorators: true,\n  });\n\n  const serviceInfo = extractServiceInfo(ast);\n\n  return generateStubCode(serviceInfo);\n}\n\nfunction extractServiceInfo(ast: any): ServiceInfo {\n  let serviceClass: ClassDeclaration | null = null;\n\n  for (const item of ast.body) {\n    if (\n      item.type === \"ExportDeclaration\" &&\n      item.declaration.type === \"ClassDeclaration\"\n    ) {\n      const classDecl = item.declaration as ClassDeclaration;\n\n      if (hasInjectableDecorator(classDecl.decorators)) {\n        serviceClass = classDecl;\n        break;\n      }\n    }\n  }\n\n  if (!serviceClass || !serviceClass.identifier) {\n    throw new Error(\"Service class is undefined\");\n  }\n\n  const className = serviceClass.identifier.value;\n  const methods = extractMethods(serviceClass);\n\n  return {\n    className,\n    methods,\n  };\n}\n\nfunction hasInjectableDecorator(decorators?: Decorator[]): boolean {\n  if (!decorators) return false;\n\n  return decorators.some((decorator) => {\n    const expr = decorator.expression;\n\n    if (expr.type === \"CallExpression\") {\n      if (\n        expr.callee.type === \"Identifier\" &&\n        expr.callee.value === \"Injectable\"\n      ) {\n        return true;\n      }\n    }\n\n    if (expr.type === \"Identifier\" && expr.value === \"Injectable\") {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction extractMethods(classDecl: ClassDeclaration): ServiceMethod[] {\n  const methods: ServiceMethod[] = [];\n\n  for (const member of classDecl.body) {\n    if (member.type === \"ClassMethod\" && member.accessibility === \"public\") {\n      const method = member as any;\n\n      const methodName =\n        method.key.type === \"Identifier\" ? method.key.value : \"\";\n\n      if (!methodName) {\n        continue;\n      }\n\n      if (!method.function.async) {\n        throw new Error(\n          `Server action ${classDecl.identifier.value}.${methodName} must be async.`\n        );\n      }\n\n      const params = extractMethodParams(method.function.params || []);\n      const returnType = extractReturnType(method.function.returnType);\n      const isAsync = method.function.async || false;\n\n      methods.push({\n        name: methodName,\n        params,\n        returnType,\n        isAsync,\n      });\n    }\n  }\n\n  return methods;\n}\n\nfunction extractMethodParams(params: any[]): MethodParam[] {\n  const result: MethodParam[] = [];\n\n  for (const param of params) {\n    if (param.type === \"Parameter\") {\n      const pat = param.pat as any;\n\n      if (pat.type === \"Identifier\") {\n        const name = pat.value;\n        const type = pat.typeAnnotation?.typeAnnotation\n          ? stringifyType(pat.typeAnnotation.typeAnnotation)\n          : \"any\";\n\n        result.push({\n          name,\n          type,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction extractReturnType(returnType?: any): string {\n  if (!returnType || !returnType.typeAnnotation) {\n    return \"any\";\n  }\n\n  const type = returnType.typeAnnotation;\n\n  if (type.type === \"TsTypeReference\") {\n    const typeName = type.typeName;\n    if (typeName.type === \"Identifier\" && typeName.value === \"Promise\") {\n      if (type.typeParams && type.typeParams.params.length > 0) {\n        return stringifyType(type.typeParams.params[0]);\n      }\n    }\n  }\n\n  return stringifyType(type);\n}\n\nfunction stringifyType(typeNode: any): string {\n  if (!typeNode) return \"any\";\n\n  switch (typeNode.type) {\n    case \"TsKeywordType\":\n      return typeNode.kind;\n\n    case \"TsTypeReference\":\n      if (typeNode.typeName.type === \"Identifier\") {\n        const baseName = typeNode.typeName.value;\n        if (typeNode.typeParams && typeNode.typeParams.params.length > 0) {\n          const params = typeNode.typeParams.params\n            .map(stringifyType)\n            .join(\", \");\n          return `${baseName}<${params}>`;\n        }\n        return baseName;\n      }\n      return \"any\";\n\n    case \"TsArrayType\":\n      return `${stringifyType(typeNode.elemType)}[]`;\n\n    case \"TsUnionType\":\n      return typeNode.types.map(stringifyType).join(\" | \");\n\n    case \"TsIntersectionType\":\n      return typeNode.types.map(stringifyType).join(\" & \");\n\n    case \"TsTypeLiteral\":\n      const props = typeNode.members\n        .map((member: any) => {\n          if (member.type === \"TsPropertySignature\") {\n            const key =\n              member.key.type === \"Identifier\" ? member.key.value : \"\";\n            const type = member.typeAnnotation\n              ? stringifyType(member.typeAnnotation.typeAnnotation)\n              : \"any\";\n            return `${key}: ${type}`;\n          }\n          return \"\";\n        })\n        .filter(Boolean);\n      return `{ ${props.join(\"; \")} }`;\n\n    default:\n      return \"any\";\n  }\n}\n\nfunction generateStubCode(serviceInfo: ServiceInfo): string {\n  const className = serviceInfo.className;\n\n  const methods = serviceInfo.methods\n    .map((method) => {\n      const params = method.params\n        .map((p) => `${p.name}: ${p.type}`)\n        .join(\", \");\n      const paramNames = method.params.map((p) => p.name).join(\", \");\n\n      const asyncKeyword = method.isAsync ? \"async \" : \"\";\n      const returnType = method.isAsync\n        ? `Promise<${method.returnType}>`\n        : method.returnType;\n\n      const hasParams = method.params.length > 0;\n      const bodyParam = hasParams ? `{ ${paramNames} }` : \"{}\";\n\n      if (!hasParams) {\n        return `  ${asyncKeyword}${method.name}(${params}): ${returnType} {\n    const response = await fetch(\\`/${className}/${method.name}\\`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n    }\n\n    return response.json();\n  }`;\n      }\n\n      return `  ${asyncKeyword}${method.name}(${params}): ${returnType} {\n    const response = await fetch(\\`/${className}/${method.name}\\`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(${bodyParam}),\n    });\n\n    if (!response.ok) {\n      throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n    }\n\n    return response.json();\n  }`;\n    })\n    .join(\"\\n\\n\");\n\n  return `import { Injectable } from \"@kithinji/orca\";\n\n@Injectable()\nexport class ${className} {\n${methods}\n}`;\n}\n", "import { parseSync } from \"@swc/core\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport type { Module, Decorator } from \"@swc/core\";\n\ntype SymbolKind =\n  | \"class\"\n  | \"function\"\n  | \"variable\"\n  | \"interface\"\n  | \"type\"\n  | \"enum\"\n  | \"namespace\"\n  | \"unknown\";\n\ninterface SymbolInfo {\n  name: string;\n  kind: SymbolKind;\n  decorators?: string[];\n  isDefault?: boolean;\n}\n\ninterface ImportInfo {\n  sourcePath: string;\n  resolvedPath: string | null;\n  symbols: SymbolInfo[];\n}\n\nexport interface FileNode {\n  filePath: string;\n  isTsx: boolean;\n  directive: \"public\" | \"interactive\" | null;\n  imports: ImportInfo[];\n  exports: SymbolInfo[];\n}\n\nexport interface DependencyGraph {\n  [filePath: string]: FileNode;\n}\n\nfunction resolveFilePath(fromFile: string, importPath: string): string | null {\n  if (!importPath.startsWith(\".\")) {\n    return null;\n  }\n\n  const dir = path.dirname(fromFile);\n  const basePath = path.resolve(dir, importPath);\n\n  const extensions = [\"\", \".ts\", \".tsx\", \".js\", \".jsx\"];\n  for (const ext of extensions) {\n    const fullPath = basePath + ext;\n    if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {\n      return fullPath;\n    }\n  }\n\n  const indexFiles = [\"/index.ts\", \"/index.tsx\", \"/index.js\", \"/index.jsx\"];\n  for (const indexFile of indexFiles) {\n    const fullPath = basePath + indexFile;\n    if (fs.existsSync(fullPath)) {\n      return fullPath;\n    }\n  }\n\n  return null;\n}\n\nfunction extractDecorators(decorators?: Decorator[]): string[] {\n  if (!decorators || decorators.length === 0) return [];\n\n  return decorators\n    .map((decorator) => {\n      if (decorator.expression.type === \"CallExpression\") {\n        if (decorator.expression.callee.type === \"Identifier\") {\n          return decorator.expression.callee.value;\n        }\n      } else if (decorator.expression.type === \"Identifier\") {\n        return decorator.expression.value;\n      }\n      return \"unknown\";\n    })\n    .filter((name) => name !== \"unknown\");\n}\n\nfunction extractDirective(ast: Module): \"public\" | \"interactive\" | null {\n  for (const item of ast.body) {\n    if (\n      item.type === \"ExpressionStatement\" &&\n      item.expression.type === \"StringLiteral\"\n    ) {\n      const value = item.expression.value;\n      if (value === \"use public\") return \"public\";\n      if (value === \"use interactive\") return \"interactive\";\n    }\n    if (\n      item.type !== \"ExpressionStatement\" ||\n      item.expression.type !== \"StringLiteral\"\n    ) {\n      break;\n    }\n  }\n  return null;\n}\n\nfunction extractExports(ast: Module): SymbolInfo[] {\n  const exports: SymbolInfo[] = [];\n\n  for (const item of ast.body) {\n    if (item.type === \"ExportDeclaration\" && item.declaration) {\n      const decl = item.declaration;\n\n      if (decl.type === \"ClassDeclaration\" && decl.identifier) {\n        const decorators = extractDecorators(decl.decorators);\n        exports.push({\n          name: decl.identifier.value,\n          kind: \"class\",\n          decorators: decorators.length > 0 ? decorators : undefined,\n        });\n      } else if (decl.type === \"FunctionDeclaration\" && decl.identifier) {\n        exports.push({ name: decl.identifier.value, kind: \"function\" });\n      } else if (decl.type === \"VariableDeclaration\") {\n        for (const declarator of decl.declarations) {\n          if (declarator.id.type === \"Identifier\") {\n            exports.push({ name: declarator.id.value, kind: \"variable\" });\n          }\n        }\n      } else if (decl.type === \"TsInterfaceDeclaration\") {\n        exports.push({ name: decl.id.value, kind: \"interface\" });\n      } else if (decl.type === \"TsTypeAliasDeclaration\") {\n        exports.push({ name: decl.id.value, kind: \"type\" });\n      } else if (decl.type === \"TsEnumDeclaration\") {\n        exports.push({ name: decl.id.value, kind: \"enum\" });\n      }\n    }\n\n    if (item.type === \"ExportNamedDeclaration\") {\n      for (const spec of item.specifiers) {\n        if (spec.type === \"ExportSpecifier\") {\n          exports.push({ name: spec.orig.value, kind: \"unknown\" });\n        }\n      }\n    }\n\n    if (item.type === \"ExportDefaultDeclaration\") {\n      const decl = item.decl;\n      let kind: SymbolKind = \"unknown\";\n      let decorators: string[] | undefined;\n\n      if (decl.type === \"ClassExpression\") {\n        kind = \"class\";\n        decorators = extractDecorators(decl.decorators);\n      } else if (decl.type === \"FunctionExpression\") {\n        kind = \"function\";\n      } else if (decl.type === \"TsInterfaceDeclaration\") {\n        kind = \"interface\";\n      }\n\n      exports.push({\n        name: \"default\",\n        kind,\n        isDefault: true,\n        decorators:\n          decorators && decorators.length > 0 ? decorators : undefined,\n      });\n    }\n\n    if (item.type === \"ExportDefaultExpression\") {\n      exports.push({ name: \"default\", kind: \"unknown\", isDefault: true });\n    }\n  }\n\n  return exports;\n}\n\nfunction extractImports(\n  ast: Module\n): Array<{ path: string; specifiers: any[] }> {\n  const imports: Array<{ path: string; specifiers: any[] }> = [];\n\n  for (const item of ast.body) {\n    if (item.type === \"ImportDeclaration\") {\n      imports.push({\n        path: item.source.value,\n        specifiers: item.specifiers,\n      });\n    }\n  }\n\n  return imports;\n}\n\nexport function buildGraph(entryPoints: string[]): DependencyGraph {\n  const graph: DependencyGraph = {};\n  const visited = new Set<string>();\n\n  function processFile(filePath: string): void {\n    const allowed =\n      filePath.endsWith(\".ts\") ||\n      filePath.endsWith(\".tsx\") ||\n      filePath.endsWith(\".js\") ||\n      filePath.endsWith(\".jsx\");\n\n    if (!allowed) return;\n\n    if (visited.has(filePath)) return;\n    visited.add(filePath);\n\n    if (!fs.existsSync(filePath)) {\n      console.warn(`File not found: ${filePath}`);\n      return;\n    }\n\n    const isTsx = filePath.endsWith(\".tsx\") || filePath.endsWith(\".jsx\");\n\n    const content = fs.readFileSync(filePath, \"utf-8\");\n    const ast = parseSync(content, {\n      syntax: \"typescript\",\n      tsx: isTsx,\n      decorators: true,\n    });\n\n    const directive = extractDirective(ast);\n    const exports = extractExports(ast);\n    const rawImports = extractImports(ast);\n\n    for (const { path: importPath } of rawImports) {\n      const resolved = resolveFilePath(filePath, importPath);\n      if (resolved) {\n        processFile(resolved);\n      }\n    }\n\n    const imports: ImportInfo[] = [];\n    for (const { path: importPath, specifiers } of rawImports) {\n      const resolvedPath = resolveFilePath(filePath, importPath);\n      const sourceExports =\n        resolvedPath && graph[resolvedPath] ? graph[resolvedPath].exports : [];\n      const symbols: SymbolInfo[] = [];\n\n      for (const spec of specifiers) {\n        if (spec.type === \"ImportDefaultSpecifier\") {\n          const defaultExport = sourceExports.find((e) => e.isDefault);\n          symbols.push({\n            name: spec.local.value,\n            kind: defaultExport?.kind || \"unknown\",\n            decorators: defaultExport?.decorators,\n            isDefault: true,\n          });\n        } else if (spec.type === \"ImportNamespaceSpecifier\") {\n          symbols.push({\n            name: spec.local.value,\n            kind: \"namespace\",\n          });\n        } else if (spec.type === \"ImportSpecifier\") {\n          const importedName = spec.imported\n            ? spec.imported.value\n            : spec.local.value;\n          const exportedSymbol = sourceExports.find(\n            (e) => e.name === importedName\n          );\n          symbols.push({\n            name: importedName,\n            kind: exportedSymbol?.kind || \"unknown\",\n            decorators: exportedSymbol?.decorators,\n          });\n        }\n      }\n\n      imports.push({\n        sourcePath: importPath,\n        resolvedPath,\n        symbols,\n      });\n    }\n\n    graph[filePath] = {\n      filePath,\n      isTsx,\n      directive,\n      imports,\n      exports,\n    };\n  }\n\n  for (const entry of entryPoints) {\n    const resolved = path.resolve(entry);\n    processFile(resolved);\n  }\n\n  return graph;\n}\n", "import { Store } from \"@/store\";\nimport { PluginBuild } from \"esbuild\";\nimport * as fs from \"fs\";\n\nexport function stylePlugin(store: Store) {\n  return {\n    name: \"style\",\n    setup(build: PluginBuild) {\n      build.onEnd(() => {\n        const styleRules = store.get(\"style_rules\");\n\n        if (!styleRules || styleRules.length === 0) {\n          console.log(\"No style rules generated\");\n          return;\n        }\n\n        const allRules = styleRules.flat();\n        const uniqueRules = [...new Set(allRules)];\n\n        const cssOutput = uniqueRules.join(\"\\n\");\n        fs.writeFileSync(\"public/index.css\", cssOutput);\n      });\n    },\n  };\n}\n", "export * from \"./config\"", "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as ts from \"typescript\";\n\nabstract class ComponentDefinition {\n  abstract name: string;\n  abstract dependencies: string[];\n  abstract generate(): string;\n}\n\nclass ButtonComponent extends ComponentDefinition {\n  name = \"button\";\n  dependencies: string[] = [];\n\n  generate(): string {\n    return `\"use interactive\";\n\nimport { Component, JSX } from \"@kithinji/orca\";\n\n@Component()\nexport class Button {\n    props!: {\n        children: any\n    };\n    \n    build() {\n        return (\n            <button>\n                {this.props.children}\n            </button>\n        );\n    }\n}\n`;\n  }\n}\n\nclass InputComponent extends ComponentDefinition {\n  name = \"input\";\n  dependencies: string[] = [];\n\n  generate(): string {\n    return `\"use interactive\";\n\nimport { Component } from \"@kithinji/orca\";\n\n@Component()\nexport class Input {    \n    build() {\n        return (\n            <input />\n        );\n    }\n}\n`;\n  }\n}\n\nclass FormComponent extends ComponentDefinition {\n  name = \"form\";\n  dependencies = [\"button\", \"input\"];\n\n  generate(): string {\n    return `\"use interactive\";\n\nimport { Component } from \"@kithinji/orca\";\nimport { Button } from \"./button.component\";\nimport { Input } from \"./input.component\";\n\n@Component()\nexport class Form {\n    props!: {\n        onSubmit?: () => void;\n    };\n    \n    build() {\n        return (\n            <form onSubmit={this.props.onSubmit}>\n                <Input />\n                <Button>Submit</Button>\n            </form>\n        );\n    }\n}\n`;\n  }\n}\n\nclass CardComponent extends ComponentDefinition {\n  name = \"card\";\n  dependencies = [\"button\"];\n\n  generate(): string {\n    return `\"use interactive\";\n    \nimport { Component } from \"@kithinji/orca\";\nimport { Button } from \"./button.component\";\n\n@Component()\nexport class Card {\n    props!: {\n        title: string;\n        children: any;\n        onAction?: () => void;\n    };\n    \n    build() {\n        return (\n            <div className=\"card\">\n                <h3>{this.props.title}</h3>\n                <div>{this.props.children}</div>\n                {this.props.onAction && (\n                    <Button onClick={this.props.onAction}>Action</Button>\n                )}\n            </div>\n        );\n    }\n}\n`;\n  }\n}\n\nclass ComponentRegistry {\n  private static components = new Map<string, ComponentDefinition>([\n    [\"button\", new ButtonComponent()],\n    [\"input\", new InputComponent()],\n    [\"form\", new FormComponent()],\n    [\"card\", new CardComponent()],\n  ]);\n\n  static get(name: string): ComponentDefinition | undefined {\n    return this.components.get(name);\n  }\n\n  static has(name: string): boolean {\n    return this.components.has(name);\n  }\n\n  static getAll(): string[] {\n    return Array.from(this.components.keys());\n  }\n\n  static register(component: ComponentDefinition): void {\n    this.components.set(component.name, component);\n  }\n}\n\nexport function addComponent(\n  name: string,\n  processedComponents: Set<string> = new Set()\n) {\n  if (processedComponents.has(name)) {\n    return;\n  }\n\n  const component = ComponentRegistry.get(name);\n  if (!component) {\n    throw new Error(\n      `Component \"${name}\" not found. Available components: ${ComponentRegistry.getAll().join(\n        \", \"\n      )}`\n    );\n  }\n\n  processedComponents.add(name);\n\n  if (component.dependencies.length > 0) {\n    console.log(\n      `\\nProcessing dependencies for \"${name}\": [${component.dependencies.join(\n        \", \"\n      )}]`\n    );\n    for (const dependency of component.dependencies) {\n      addComponent(dependency, processedComponents);\n    }\n  }\n\n  const componentModulePath = path.join(\n    process.cwd(),\n    \"src/component/component.module.ts\"\n  );\n  const componentPath = path.join(\n    process.cwd(),\n    `src/component/component/${name}.component.tsx`\n  );\n  const componentDir = path.dirname(componentPath);\n  const appModulePath = path.join(process.cwd(), \"src/app/app.module.ts\");\n\n  if (!fs.existsSync(componentModulePath)) {\n    const moduleDir = path.dirname(componentModulePath);\n    if (!fs.existsSync(moduleDir)) {\n      fs.mkdirSync(moduleDir, { recursive: true });\n    }\n    fs.writeFileSync(componentModulePath, createModule(), \"utf-8\");\n  }\n\n  if (!fs.existsSync(componentDir)) {\n    fs.mkdirSync(componentDir, { recursive: true });\n  }\n\n  if (!fs.existsSync(componentPath)) {\n    fs.writeFileSync(componentPath, component.generate(), \"utf-8\");\n    console.log(`Created ${name}.component.tsx`);\n  } else {\n    console.log(`${name}.component.tsx already exists, skipping file creation`);\n  }\n\n  const moduleContent = fs.readFileSync(componentModulePath, \"utf-8\");\n  const updatedModule = updateModuleWithComponent(moduleContent, name);\n  fs.writeFileSync(componentModulePath, updatedModule, \"utf-8\");\n\n  if (fs.existsSync(appModulePath)) {\n    const appModuleContent = fs.readFileSync(appModulePath, \"utf-8\");\n    const updatedAppModule = ensureComponentModuleImported(appModuleContent);\n    if (updatedAppModule !== appModuleContent) {\n      fs.writeFileSync(appModulePath, updatedAppModule, \"utf-8\");\n    }\n  }\n}\n\nexport function getComponentDependencies(\n  name: string,\n  visited: Set<string> = new Set()\n): string[] {\n  if (visited.has(name)) {\n    return [];\n  }\n\n  const component = ComponentRegistry.get(name);\n  if (!component) {\n    return [];\n  }\n\n  visited.add(name);\n  const allDeps: string[] = [];\n\n  for (const dep of component.dependencies) {\n    allDeps.push(dep);\n    allDeps.push(...getComponentDependencies(dep, visited));\n  }\n\n  return [...new Set(allDeps)];\n}\n\nexport function printDependencyTree(name: string, indent: string = \"\"): void {\n  const component = ComponentRegistry.get(name);\n  if (!component) {\n    console.log(`${indent}${name} (not found)`);\n    return;\n  }\n\n  console.log(`${indent}${name}`);\n  for (const dep of component.dependencies) {\n    printDependencyTree(dep, indent + \"  \u251C\u2500 \");\n  }\n}\n\nexport function listComponents(): void {\n  console.log(\"\\nAvailable components:\");\n  for (const name of ComponentRegistry.getAll()) {\n    const component = ComponentRegistry.get(name)!;\n    const depsInfo =\n      component.dependencies.length > 0\n        ? ` (depends on: ${component.dependencies.join(\", \")})`\n        : \" (no dependencies)\";\n    console.log(`  - ${name}${depsInfo}`);\n  }\n}\n\nfunction updateModuleWithComponent(\n  moduleContent: string,\n  componentName: string\n): string {\n  const className = capitalize(componentName);\n  const importPath = `./component/${componentName}.component`;\n\n  const sourceFile = ts.createSourceFile(\n    \"component.module.ts\",\n    moduleContent,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  const hasImport = sourceFile.statements.some((statement) => {\n    if (ts.isImportDeclaration(statement)) {\n      const moduleSpecifier = statement.moduleSpecifier;\n      if (ts.isStringLiteral(moduleSpecifier)) {\n        return moduleSpecifier.text === importPath;\n      }\n    }\n    return false;\n  });\n\n  if (hasImport) {\n    return moduleContent;\n  }\n\n  let lastImportEnd = 0;\n  sourceFile.statements.forEach((statement) => {\n    if (ts.isImportDeclaration(statement)) {\n      lastImportEnd = statement.end;\n    }\n  });\n\n  const importStatement = `import { ${className} } from \"${importPath}\";\\n`;\n  let updatedContent =\n    moduleContent.slice(0, lastImportEnd) +\n    \"\\n\" +\n    importStatement +\n    moduleContent.slice(lastImportEnd);\n\n  const newSourceFile = ts.createSourceFile(\n    \"component.module.ts\",\n    updatedContent,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  updatedContent = addToDecoratorArray(\n    updatedContent,\n    newSourceFile,\n    \"declarations\",\n    className\n  );\n  updatedContent = addToDecoratorArray(\n    updatedContent,\n    ts.createSourceFile(\n      \"component.module.ts\",\n      updatedContent,\n      ts.ScriptTarget.Latest,\n      true\n    ),\n    \"exports\",\n    className\n  );\n\n  return updatedContent;\n}\n\nfunction addToDecoratorArray(\n  content: string,\n  sourceFile: ts.SourceFile,\n  arrayName: string,\n  className: string\n): string {\n  let decoratorNode: ts.Decorator | undefined;\n\n  sourceFile.statements.forEach((statement) => {\n    if (ts.isClassDeclaration(statement) && statement.modifiers) {\n      statement.modifiers.forEach((modifier) => {\n        if (ts.isDecorator(modifier)) {\n          const expression = modifier.expression;\n          if (ts.isCallExpression(expression)) {\n            const expressionText = expression.expression.getText(sourceFile);\n            if (expressionText === \"Module\") {\n              decoratorNode = modifier;\n            }\n          }\n        }\n      });\n    }\n  });\n\n  if (!decoratorNode) {\n    console.warn(\"Could not find @Module decorator\");\n    return content;\n  }\n\n  const callExpression = decoratorNode.expression as ts.CallExpression;\n  const objectLiteral = callExpression\n    .arguments[0] as ts.ObjectLiteralExpression;\n\n  if (!objectLiteral || !ts.isObjectLiteralExpression(objectLiteral)) {\n    return content;\n  }\n\n  let targetProperty: ts.PropertyAssignment | undefined;\n  objectLiteral.properties.forEach((prop) => {\n    if (ts.isPropertyAssignment(prop)) {\n      const propName = prop.name.getText(sourceFile);\n      if (propName === arrayName) {\n        targetProperty = prop;\n      }\n    }\n  });\n\n  if (!targetProperty) {\n    console.warn(`Could not find ${arrayName} property`);\n    return content;\n  }\n\n  const arrayLiteral = targetProperty.initializer;\n  if (!ts.isArrayLiteralExpression(arrayLiteral)) {\n    return content;\n  }\n\n  const hasClassName = arrayLiteral.elements.some((element) => {\n    return element.getText(sourceFile).trim() === className;\n  });\n\n  if (hasClassName) {\n    return content;\n  }\n\n  const arrayStart = arrayLiteral.getStart(sourceFile);\n  const arrayEnd = arrayLiteral.getEnd();\n\n  if (arrayLiteral.elements.length === 0) {\n    const newArray = `[${className}]`;\n    return (\n      content.substring(0, arrayStart) + newArray + content.substring(arrayEnd)\n    );\n  }\n\n  const lastElement = arrayLiteral.elements[arrayLiteral.elements.length - 1];\n  const insertPos = lastElement.getEnd();\n  const newElement = `, ${className}`;\n\n  return (\n    content.substring(0, insertPos) + newElement + content.substring(insertPos)\n  );\n}\n\nfunction ensureComponentModuleImported(appModuleContent: string): string {\n  const sourceFile = ts.createSourceFile(\n    \"app.module.ts\",\n    appModuleContent,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  const hasComponentModuleImport = sourceFile.statements.some((statement) => {\n    if (ts.isImportDeclaration(statement) && statement.importClause) {\n      const namedBindings = statement.importClause.namedBindings;\n      if (namedBindings && ts.isNamedImports(namedBindings)) {\n        return namedBindings.elements.some(\n          (element) => element.name.text === \"ComponentModule\"\n        );\n      }\n    }\n    return false;\n  });\n\n  if (hasComponentModuleImport) {\n    return ensureInImportsArray(appModuleContent, sourceFile);\n  }\n\n  let lastImportEnd = 0;\n  sourceFile.statements.forEach((statement) => {\n    if (ts.isImportDeclaration(statement)) {\n      lastImportEnd = statement.end;\n    }\n  });\n\n  const importStatement = `import { ComponentModule } from \"../component/component.module\";\\n`;\n  let updatedContent =\n    appModuleContent.slice(0, lastImportEnd) +\n    \"\\n\" +\n    importStatement +\n    appModuleContent.slice(lastImportEnd);\n\n  const newSourceFile = ts.createSourceFile(\n    \"app.module.ts\",\n    updatedContent,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  updatedContent = ensureInImportsArray(updatedContent, newSourceFile);\n\n  return updatedContent;\n}\n\nfunction ensureInImportsArray(\n  content: string,\n  sourceFile: ts.SourceFile\n): string {\n  return addToDecoratorArray(content, sourceFile, \"imports\", \"ComponentModule\");\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction createModule() {\n  return `import { Module } from \"@kithinji/orca\";\n\n@Module({\n    imports: [],\n    providers: [],\n    declarations: [],\n    exports: [],\n})\nexport class ComponentModule {}\n`;\n}\n", "export function toCamelCase(str: string): string {\n  return str\n    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())\n    .replace(/^./, (char) => char.toLowerCase());\n}\n\nexport function toPascalCase(str: string): string {\n  return str\n    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())\n    .replace(/^./, (char) => char.toUpperCase());\n}\n\nexport function toSnakeCase(str: string): string {\n  return str.replace(/[-\\s]/g, \"_\").toLowerCase();\n}\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\n\ninterface FileEntry {\n  name: string;\n  content: string;\n}\n\nexport interface DirEntry {\n  name?: string;\n  files?: FileEntry[];\n  dirs?: DirEntry[];\n}\n\nexport function createStructure(basePath: string, entry: DirEntry) {\n  fs.mkdirSync(basePath, { recursive: true });\n\n  entry.files?.forEach((file) => {\n    fs.writeFileSync(path.join(basePath, file.name), file.content);\n  });\n\n  entry.dirs?.forEach((dir) => {\n    const dirPath = path.join(basePath, dir.name || \"\");\n    createStructure(dirPath, dir);\n  });\n}\n", "import { createStructure, DirEntry } from \"@/utils\";\nimport path from \"path\";\nimport { addModule } from \"../module\";\nimport { addComponent } from \"../component\";\n\nexport function addNew(name: string) {\n  const baseDir = path.join(process.cwd(), name);\n\n  const structure: DirEntry = {\n    files: [\n      { name: \"package.json\", content: genPackageJson(name) },\n      { name: \"tsconfig.json\", content: gentsconfig() },\n      { name: \"pod.config.ts\", content: genPodConfig(name) },\n      { name: \"README.md\", content: genReadMe() },\n      { name: \".gitignore\", content: genGitIgnore() },\n      { name: \".env\", content: genEnv() },\n    ],\n    dirs: [\n      {\n        name: \"src\",\n        files: [{ name: \"main.ts\", content: genMainTs() }],\n      },\n    ],\n  };\n\n  createStructure(baseDir, structure);\n\n  const appDir = path.join(process.cwd(), name, \"src\", \"app\");\n\n  addModule(\"app\", appDir);\n\n  process.chdir(baseDir);\n\n  addComponent(\"button\");\n\n  console.log(`App ${name} created successfully`);\n}\n\nfunction genPackageJson(name: string) {\n  const pj = {\n    name,\n    private: true,\n    version: \"0.0.0\",\n    type: \"module\",\n    scripts: {\n      dev: \"pod dev\",\n      build: \"pod build\",\n      start: \"pod start\",\n    },\n    dependencies: {\n      \"reflect-metadata\": \"latest\",\n      zod: \"^4.2.1\",\n      \"@kithinji/orca\": \"latest\",\n    },\n    devDependencies: {\n      \"@types/node\": \"^20.19.27\",\n      typescript: \"~5.9.3\",\n      \"@kithinji/pod\": \"latest\",\n    },\n  };\n\n  return JSON.stringify(pj, null, 2);\n}\n\nfunction gentsconfig() {\n  const tsconfig = {\n    compilerOptions: {\n      target: \"ES2020\",\n      module: \"ESNext\",\n      moduleResolution: \"bundler\",\n      strict: true,\n      esModuleInterop: true,\n      skipLibCheck: true,\n      jsx: \"react-jsx\",\n      jsxImportSource: \"@kithinji/orca\",\n      experimentalDecorators: true,\n      emitDecoratorMetadata: true,\n      baseUrl: \".\",\n      paths: {\n        \"@/*\": [\"src/*\"],\n      },\n    },\n    include: [\"src\"],\n  };\n\n  return JSON.stringify(tsconfig, null, 2);\n}\n\nfunction genPodConfig(name: string) {\n  return `import { PodConfig, stylePlugin } from \"@kithinji/pod\";\n\nexport default function defaultConfig(): PodConfig {\n  return {\n    name: \"${name}\",\n    client_plugins: [stylePlugin],\n  };\n}  \n`;\n}\n\nfunction genReadMe() {\n  return `# Pod Project  \n`;\n}\n\nfunction genGitIgnore() {\n  return `node_modules\ndist\nbuild\n.orca\n*.log\n.env\n.DS_Store\n`;\n}\n\nfunction genEnv() {\n  return `NODE_ENV=development\n`;\n}\n\nfunction genMainTs() {\n  return `import { NodeFactory } from \"@kithinji/orca\";\nimport { AppModule } from \"./app/app.module\";\n\nasync function bootstrap() {\n  const app = await NodeFactory.create(AppModule);\n  app.listen(8080, () => {\n    console.log(\"Server started\");\n  });\n}\n\nbootstrap();\n`;\n}\n", "import { createStructure, DirEntry, toCamelCase, toPascalCase } from \"@/utils\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\nimport * as ts from \"typescript\";\n\nexport function addFeature(name: string) {\n  const featureDir = path.join(process.cwd(), \"src\", \"features\", name);\n\n  addModule(name, featureDir);\n\n  updateFeaturesIndex(name);\n\n  updateAppModule(name);\n}\n\nexport function addModule(name: string, baseDir: string) {\n  const structure: DirEntry = {\n    files: [\n      { name: `${name}.module.ts`, content: createModule(name) },\n      { name: `${name}.service.ts`, content: createService(name) },\n      { name: `${name}.page.tsx`, content: createPage(name) },\n    ],\n    dirs: [\n      {\n        name: \"schemas\",\n        files: [\n          {\n            name: \"get.ts\",\n            content: createGetSchema(name),\n          },\n          {\n            name: \"create.ts\",\n            content: createCreateSchema(name),\n          },\n          {\n            name: \"update.ts\",\n            content: createUpdateSchema(name),\n          },\n          {\n            name: \"list.ts\",\n            content: createListSchema(name),\n          },\n          {\n            name: \"delete.ts\",\n            content: createDeleteSchema(name),\n          },\n        ],\n      },\n      {\n        name: \"components\",\n        files: [\n          {\n            name: `${name}-list.component.tsx`,\n            content: createListComponent(name),\n          },\n        ],\n      },\n    ],\n  };\n\n  createStructure(baseDir, structure);\n}\n\nfunction updateFeaturesIndex(featureName: string) {\n  const featuresIndexPath = path.join(\n    process.cwd(),\n    \"src\",\n    \"features\",\n    \"index.ts\"\n  );\n\n  const moduleName = toPascalCase(featureName + \"_\" + \"Module\");\n  const importPath = `./${featureName}/${featureName}.module`;\n\n  if (fs.existsSync(featuresIndexPath)) {\n    let content = fs.readFileSync(featuresIndexPath, \"utf-8\");\n    const sourceFile = ts.createSourceFile(\n      \"index.ts\",\n      content,\n      ts.ScriptTarget.Latest,\n      true\n    );\n\n    const hasExport = sourceFile.statements.some((statement) => {\n      if (ts.isExportDeclaration(statement)) {\n        const moduleSpecifier = statement.moduleSpecifier;\n        if (moduleSpecifier && ts.isStringLiteral(moduleSpecifier)) {\n          return moduleSpecifier.text === importPath;\n        }\n        if (\n          statement.exportClause &&\n          ts.isNamedExports(statement.exportClause)\n        ) {\n          return statement.exportClause.elements.some(\n            (element) => element.name.text === moduleName\n          );\n        }\n      }\n      return false;\n    });\n\n    if (hasExport) {\n      return;\n    }\n\n    const exportStatement = `export { ${moduleName} } from \"${importPath}\";\\n`;\n    fs.appendFileSync(featuresIndexPath, exportStatement);\n  } else {\n    const featuresDir = path.dirname(featuresIndexPath);\n    if (!fs.existsSync(featuresDir)) {\n      fs.mkdirSync(featuresDir, { recursive: true });\n    }\n\n    const exportStatement = `export { ${moduleName} } from \"${importPath}\";\\n`;\n    fs.writeFileSync(featuresIndexPath, exportStatement, \"utf-8\");\n  }\n}\n\nfunction updateAppModule(featureName: string) {\n  const appModulePath = path.join(process.cwd(), \"src\", \"app\", \"app.module.ts\");\n\n  if (!fs.existsSync(appModulePath)) {\n    return;\n  }\n\n  const moduleName = toPascalCase(featureName + \"_\" + \"Module\");\n  let content = fs.readFileSync(appModulePath, \"utf-8\");\n\n  const sourceFile = ts.createSourceFile(\n    \"app.module.ts\",\n    content,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  const hasImport = sourceFile.statements.some((statement) => {\n    if (ts.isImportDeclaration(statement)) {\n      const moduleSpecifier = statement.moduleSpecifier;\n      if (ts.isStringLiteral(moduleSpecifier)) {\n        const importPath = moduleSpecifier.text;\n        return importPath.includes(`/${featureName}/${featureName}.module`);\n      }\n\n      if (\n        statement.importClause?.namedBindings &&\n        ts.isNamedImports(statement.importClause.namedBindings)\n      ) {\n        return statement.importClause.namedBindings.elements.some(\n          (element) => element.name.text === moduleName\n        );\n      }\n    }\n    return false;\n  });\n\n  if (hasImport) {\n    content = addToModuleImportsArray(content, sourceFile, moduleName);\n    fs.writeFileSync(appModulePath, content, \"utf-8\");\n    return;\n  }\n\n  let lastImportEnd = 0;\n  sourceFile.statements.forEach((statement) => {\n    if (ts.isImportDeclaration(statement)) {\n      lastImportEnd = statement.end;\n    }\n  });\n\n  const importStatement = `import { ${moduleName} } from \"../features/${featureName}/${featureName}.module\";\\n`;\n  content =\n    content.slice(0, lastImportEnd) +\n    \"\\n\" +\n    importStatement +\n    content.slice(lastImportEnd);\n\n  const newSourceFile = ts.createSourceFile(\n    \"app.module.ts\",\n    content,\n    ts.ScriptTarget.Latest,\n    true\n  );\n\n  content = addToModuleImportsArray(content, newSourceFile, moduleName);\n\n  fs.writeFileSync(appModulePath, content, \"utf-8\");\n}\n\nfunction addToModuleImportsArray(\n  content: string,\n  sourceFile: ts.SourceFile,\n  moduleName: string\n): string {\n  let decoratorNode: ts.Decorator | undefined;\n\n  sourceFile.statements.forEach((statement) => {\n    if (ts.isClassDeclaration(statement) && statement.modifiers) {\n      statement.modifiers.forEach((modifier) => {\n        if (ts.isDecorator(modifier)) {\n          const expression = modifier.expression;\n          if (ts.isCallExpression(expression)) {\n            const expressionText = expression.expression.getText(sourceFile);\n            if (expressionText === \"Module\") {\n              decoratorNode = modifier;\n            }\n          }\n        }\n      });\n    }\n  });\n\n  if (!decoratorNode) {\n    return content;\n  }\n\n  const callExpression = decoratorNode.expression as ts.CallExpression;\n  const objectLiteral = callExpression\n    .arguments[0] as ts.ObjectLiteralExpression;\n\n  if (!objectLiteral || !ts.isObjectLiteralExpression(objectLiteral)) {\n    return content;\n  }\n\n  let importsProperty: ts.PropertyAssignment | undefined;\n  objectLiteral.properties.forEach((prop) => {\n    if (ts.isPropertyAssignment(prop)) {\n      const propName = prop.name.getText(sourceFile);\n      if (propName === \"imports\") {\n        importsProperty = prop;\n      }\n    }\n  });\n\n  if (!importsProperty) {\n    return content;\n  }\n\n  const arrayLiteral = importsProperty.initializer;\n  if (!ts.isArrayLiteralExpression(arrayLiteral)) {\n    return content;\n  }\n\n  const hasModule = arrayLiteral.elements.some((element) => {\n    return element.getText(sourceFile).trim() === moduleName;\n  });\n\n  if (hasModule) {\n    return content;\n  }\n\n  const arrayStart = arrayLiteral.getStart(sourceFile);\n  const arrayEnd = arrayLiteral.getEnd();\n\n  if (arrayLiteral.elements.length === 0) {\n    const newArray = `[${moduleName}]`;\n    return (\n      content.substring(0, arrayStart) + newArray + content.substring(arrayEnd)\n    );\n  }\n\n  const lastElement = arrayLiteral.elements[arrayLiteral.elements.length - 1];\n  const insertPos = lastElement.getEnd();\n  const newElement = `, ${moduleName}`;\n\n  return (\n    content.substring(0, insertPos) + newElement + content.substring(insertPos)\n  );\n}\n\nfunction createModule(name: string) {\n  const serviceName = toPascalCase(name + \"_\" + \"Service\");\n  const pageName = toPascalCase(name + \"_\" + \"Page\");\n  const moduleName = toPascalCase(name + \"_\" + \"Module\");\n  const componentName = toPascalCase(name + \"_\" + \"List\");\n\n  return `import { Module } from \"@kithinji/orca\";\nimport { ComponentModule } from \"@/component/component.module\";\nimport { ${serviceName} } from \"./${name}.service\";\nimport { ${pageName} } from \"./${name}.page\";\nimport { ${componentName} } from \"./components/${name}-list.component\";\n\n@Module({\n    imports: [ComponentModule],\n    providers: [${serviceName}],\n    declarations: [${pageName}, ${componentName}],\n    exports: [${serviceName}, ${pageName}]\n})\nexport class ${moduleName} {}\n`;\n}\n\nfunction createGetSchema(name: string) {\n  return `import { z } from \"zod\";\n\nexport const ${toCamelCase(name + \"_\" + \"GetInput\")} = z.object({\n  id: z.string().uuid(),\n});\n\nexport const ${toCamelCase(name + \"_\" + \"GetOutput\")} = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n  description: z.string().optional(),\n  createdAt: z.date(),\n  updatedAt: z.date().optional(),\n});\n`;\n}\n\nfunction createCreateSchema(name: string) {\n  return `import { z } from \"zod\";\n\nexport const ${toCamelCase(name + \"_\" + \"CreateInput\")} = z.object({\n  name: z.string().min(1),\n  description: z.string().optional(),\n});\n\nexport const ${toCamelCase(name + \"_\" + \"CreateOutput\")} = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n  description: z.string().optional(),\n  createdAt: z.date(),\n});\n`;\n}\n\nfunction createUpdateSchema(name: string) {\n  return `import { z } from \"zod\";\n\nexport const ${toCamelCase(name + \"_\" + \"UpdateInput\")} = z.object({\n  id: z.string().uuid(),\n  name: z.string().min(1).optional(),\n  description: z.string().optional(),\n});\n\nexport const ${toCamelCase(name + \"_\" + \"UpdateOutput\")} = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n  description: z.string().optional(),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n});\n`;\n}\n\nfunction createListSchema(name: string) {\n  return `import { z } from \"zod\";\n\nexport const ${toCamelCase(name + \"_\" + \"ListOutput\")} = z.array(\n  z.object({\n    id: z.string().uuid(),\n    name: z.string(),\n    description: z.string().optional(),\n    createdAt: z.date(),\n    updatedAt: z.date().optional(),\n  })\n);\n`;\n}\n\nfunction createDeleteSchema(name: string) {\n  return `import { z } from \"zod\";\n\nexport const ${toCamelCase(name + \"_\" + \"DeleteInput\")} = z.object({\n  id: z.string().uuid(),\n});\n\nexport const ${toCamelCase(name + \"_\" + \"DeleteOutput\")} = z.object({\n  id: z.string().uuid(),\n  name: z.string(),\n  description: z.string().optional(),\n  createdAt: z.date(),\n  updatedAt: z.date().optional(),\n});\n`;\n}\n\nfunction createService(name: string) {\n  const serviceName = toPascalCase(name + \"_\" + \"Service\");\n\n  return `\"use public\";\n\nimport { Injectable, Signature } from \"@kithinji/orca\";\nimport { \n  ${toCamelCase(name + \"_\" + \"CreateInput\")}, \n  ${toCamelCase(name + \"_\" + \"CreateOutput\")} \n} from \"./schemas/create\";\nimport { \n  ${toCamelCase(name + \"_\" + \"GetInput\")}, \n  ${toCamelCase(name + \"_\" + \"GetOutput\")} \n} from \"./schemas/get\";\nimport { \n  ${toCamelCase(name + \"_\" + \"UpdateInput\")}, \n  ${toCamelCase(name + \"_\" + \"UpdateOutput\")} \n} from \"./schemas/update\";\nimport { ${toCamelCase(name + \"_\" + \"ListOutput\")} } from \"./schemas/list\";\nimport { \n  ${toCamelCase(name + \"_\" + \"DeleteInput\")}, \n  ${toCamelCase(name + \"_\" + \"DeleteOutput\")} \n} from \"./schemas/delete\";\n\n@Injectable()\nexport class ${serviceName} {\n    private items: any[] = [];\n\n    @Signature(${toCamelCase(name + \"_\" + \"CreateInput\")}, ${toCamelCase(\n    name + \"_\" + \"CreateOutput\"\n  )})\n    public async create(input: any) {\n        const item = {\n            id: crypto.randomUUID(),\n            ...input,\n            createdAt: new Date(),\n        };\n        this.items.push(item);\n        return item;\n    }\n\n    @Signature(${toCamelCase(name + \"_\" + \"GetInput\")}, ${toCamelCase(\n    name + \"_\" + \"GetOutput\"\n  )})\n    public async get(input: any) {\n        const item = this.items.find((i) => i.id === input.id);\n        if (!item) {\n            throw new Error(\"Item not found\");\n        }\n        return item;\n    }\n\n    @Signature(${toCamelCase(name + \"_\" + \"ListOutput\")})\n    public async list() {\n        return this.items;\n    }\n\n    @Signature(${toCamelCase(name + \"_\" + \"UpdateInput\")}, ${toCamelCase(\n    name + \"_\" + \"UpdateOutput\"\n  )})\n    public async update(input: any) {\n        const index = this.items.findIndex((i) => i.id === input.id);\n        if (index === -1) {\n            throw new Error(\"Item not found\");\n        }\n        \n        this.items[index] = {\n            ...this.items[index],\n            ...input,\n            updatedAt: new Date(),\n        };\n        \n        return this.items[index];\n    }\n\n    @Signature(${toCamelCase(name + \"_\" + \"DeleteInput\")}, ${toCamelCase(\n    name + \"_\" + \"DeleteOutput\"\n  )})\n    public async delete(input: any) {\n        const index = this.items.findIndex((i) => i.id === input.id);\n        if (index === -1) {\n            throw new Error(\"Item not found\");\n        }\n        \n        const deleted = this.items.splice(index, 1)[0];\n        return deleted;\n    }\n}\n`;\n}\n\nfunction createPage(name: string) {\n  const pageName = toPascalCase(name + \"_\" + \"Page\");\n  const serviceName = toPascalCase(name + \"_\" + \"Service\");\n  const serviceVar = toCamelCase(name + \"_\" + \"Service\");\n  const listComponent = toPascalCase(name + \"_\" + \"List\");\n\n  return `import { Component } from \"@kithinji/orca\";\nimport { ${serviceName} } from \"./${name}.service\";\nimport { ${listComponent} } from \"./components/${name}-list.component\";\n\n@Component()\nexport class ${pageName} {\n    constructor(\n        public ${serviceVar}: ${serviceName}\n    ) {}\n\n    build() {\n        return (\n            <div>\n                <h1>${toPascalCase(name)} Management</h1>\n                <${listComponent} service={this.${serviceVar}} />\n            </div>\n        );\n    }\n}\n`;\n}\n\nfunction createListComponent(name: string) {\n  const componentName = toPascalCase(name + \"_\" + \"List\");\n  const serviceName = toPascalCase(name + \"_\" + \"Service\");\n\n  return `\"use interactive\";\n\nimport { Component } from \"@kithinji/orca\";\nimport { ${serviceName} } from \"../${name}.service\";\n\n@Component()\nexport class ${componentName} {\n    props!: {\n        service: ${serviceName};\n    };\n\n    build() {\n        return (\n            <div>\n                <h2>${toPascalCase(name)} List</h2>\n                <p>List component for ${name}</p>\n                {/* Add your list implementation here */}\n            </div>\n        );\n    }\n}\n`;\n}\n", "import fs from \"fs-extra\";\nimport path from \"path\";\nimport prompts from \"prompts\";\nimport yaml from \"js-yaml\";\n\ninterface PackageJson {\n  name: string;\n  dependencies?: Record<string, string>;\n}\n\ninterface DockerService {\n  name: string;\n  needsTunnel?: boolean;\n}\n\nexport async function dockerize(env: \"dev\" | \"prod\" = \"prod\") {\n  const cwd = process.cwd();\n  const packageJsonPath = path.join(cwd, \"package.json\");\n\n  if (!fs.existsSync(packageJsonPath)) {\n    throw new Error(\"package.json not found. Are you in a Pod project?\");\n  }\n\n  const packageJson: PackageJson = await fs.readJSON(packageJsonPath);\n  const projectName = packageJson.name;\n\n  const detectedServices = detectServices(packageJson);\n  const selectedServices = await selectServices(detectedServices);\n\n  await restructureProject(cwd, projectName);\n  await createDockerfile(cwd, projectName);\n\n  if (env === \"prod\") {\n    await setupProduction(cwd, projectName, selectedServices);\n  } else {\n    await setupDevelopment(cwd, projectName, selectedServices);\n  }\n\n  printNextSteps(projectName, env, selectedServices);\n}\n\nfunction detectServices(packageJson: PackageJson): DockerService[] {\n  const deps = packageJson.dependencies || {};\n  const services: DockerService[] = [];\n\n  if (deps.pg || deps.postgres) services.push({ name: \"postgres\" });\n  if (deps.mysql || deps.mysql2) services.push({ name: \"mysql\" });\n  if (deps.redis || deps.ioredis) services.push({ name: \"redis\" });\n  if (deps.mongodb || deps.mongoose) services.push({ name: \"mongodb\" });\n\n  return services;\n}\n\nasync function selectServices(\n  detected: DockerService[]\n): Promise<DockerService[]> {\n  if (detected.length === 0) return [];\n\n  const response = await prompts({\n    type: \"multiselect\",\n    name: \"services\",\n    message: \"Select services to include:\",\n    choices: detected.map((s) => ({\n      title: s.name,\n      value: s.name,\n      selected: true,\n    })),\n  });\n\n  if (!response.services) return [];\n  return detected.filter((s) => response.services.includes(s.name));\n}\n\nasync function restructureProject(cwd: string, projectName: string) {\n  const nestedDir = path.join(cwd, projectName);\n\n  if (fs.existsSync(nestedDir)) {\n    console.log(\"\u26A0\uFE0F  Project already restructured, skipping...\");\n    return;\n  }\n\n  await fs.ensureDir(nestedDir);\n\n  const items = await fs.readdir(cwd);\n  const toMove = items.filter((item) => item !== projectName);\n\n  for (const item of toMove) {\n    const src = path.join(cwd, item);\n    const dest = path.join(nestedDir, item);\n    await fs.move(src, dest, { overwrite: true });\n  }\n\n  const envSrc = path.join(nestedDir, \".env\");\n  const envDest = path.join(cwd, \".env\");\n\n  if (fs.existsSync(envSrc)) {\n    await fs.move(envSrc, envDest, { overwrite: true });\n  }\n}\n\nasync function createDockerfile(cwd: string, projectName: string) {\n  const dockerfilePath = path.join(cwd, projectName, \"Dockerfile\");\n\n  const dockerfile = `FROM node:18-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN if [ -f \"tsconfig.json\" ]; then npm run build || true; fi\n\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n`;\n\n  await fs.writeFile(dockerfilePath, dockerfile);\n}\n\nasync function setupProduction(\n  cwd: string,\n  projectName: string,\n  services: DockerService[]\n) {\n  const compose: any = {\n    services: {\n      traefik: {\n        image: \"traefik:v2.10\",\n        command: [\n          \"--api.insecure=true\",\n          \"--providers.docker=true\",\n          \"--providers.docker.exposedbydefault=false\",\n          \"--entrypoints.web.address=:80\",\n          \"--entrypoints.websecure.address=:443\",\n          \"--certificatesresolvers.myresolver.acme.tlschallenge=true\",\n          \"--certificatesresolvers.myresolver.acme.email=admin@example.com\",\n          \"--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json\",\n        ],\n        ports: [\"80:80\", \"443:443\", \"8080:8080\"],\n        volumes: [\n          \"/var/run/docker.sock:/var/run/docker.sock:ro\",\n          \"./letsencrypt:/letsencrypt\",\n        ],\n        networks: [\"web\"],\n      },\n      [projectName]: {\n        build: \".\",\n        labels: [\n          \"traefik.enable=true\",\n          \"traefik.http.routers.app.rule=Host(`localhost`)\",\n          \"traefik.http.routers.app.entrypoints=websecure\",\n          \"traefik.http.routers.app.tls.certresolver=myresolver\",\n          \"traefik.http.services.app.loadbalancer.server.port=3000\",\n        ],\n        env_file: [\".env\"],\n        depends_on: [],\n        networks: [\"web\"],\n      },\n    },\n    networks: {\n      web: {\n        driver: \"bridge\",\n      },\n    },\n    volumes: {},\n  };\n\n  for (const service of services) {\n    const config = getServiceConfig(service.name);\n    compose.services[service.name] = config.service;\n    if (config.volume) {\n      compose.volumes[config.volume.name] = {};\n    }\n    compose.services[projectName].depends_on.push(service.name);\n  }\n\n  const composePath = path.join(cwd, \"docker-compose.yml\");\n  await fs.writeFile(\n    composePath,\n    yaml.dump(compose, { indent: 2, lineWidth: -1 })\n  );\n  await createEnvTemplate(cwd, services, \"prod\");\n}\n\nasync function setupDevelopment(\n  cwd: string,\n  projectName: string,\n  services: DockerService[]\n) {\n  const existingCompose = path.join(cwd, \"docker-compose.yml\");\n\n  let existingServices: DockerService[] = [];\n\n  if (fs.existsSync(existingCompose)) {\n    const content = await fs.readFile(existingCompose, \"utf8\");\n    const existing: any = yaml.load(content);\n    if (existing.services) {\n      existingServices = Object.keys(existing.services)\n        .filter((s) => [\"postgres\", \"mysql\", \"redis\", \"mongodb\"].includes(s))\n        .map((name) => ({ name }));\n    }\n  }\n\n  const servicesToTunnel: DockerService[] = [];\n\n  if (existingServices.length > 0) {\n    const { tunnel } = await prompts({\n      type: \"confirm\",\n      name: \"tunnel\",\n      message: \"Tunnel to remote database services?\",\n      initial: false,\n    });\n\n    if (tunnel) {\n      const { selected } = await prompts({\n        type: \"multiselect\",\n        name: \"selected\",\n        message: \"Select services to tunnel:\",\n        choices: existingServices.map((s) => ({\n          title: s.name,\n          value: s.name,\n        })),\n      });\n\n      if (selected) {\n        servicesToTunnel.push(\n          ...existingServices\n            .filter((s) => selected.includes(s.name))\n            .map((s) => ({ ...s, needsTunnel: true }))\n        );\n      }\n    }\n  }\n\n  for (const service of servicesToTunnel) {\n    await createTunnelService(cwd, service.name);\n  }\n\n  const compose: any = {\n    services: {\n      [projectName]: {\n        build: \".\",\n        ports: [\"3000:3000\"],\n        env_file: [\".env\"],\n        volumes: [\".:/app\", \"/app/node_modules\"],\n        command: \"npm run dev\",\n        depends_on: [],\n      },\n    },\n    networks: {\n      default: {\n        driver: \"bridge\",\n      },\n    },\n  };\n\n  for (const service of servicesToTunnel) {\n    const tunnelName = `${service.name}-tunnel`;\n    compose.services[tunnelName] = {\n      build: `./${tunnelName}`,\n      environment: [\n        `REMOTE_HOST=\\${${service.name.toUpperCase()}_REMOTE_HOST}`,\n        `REMOTE_PORT=\\${${service.name.toUpperCase()}_REMOTE_PORT:-${getDefaultPort(\n          service.name\n        )}}`,\n        `LOCAL_PORT=${getDefaultPort(service.name)}`,\n      ],\n      volumes: [`./${service.name}.pem:/ssh/${service.name}.pem:ro`],\n    };\n    compose.services[projectName].depends_on.push(tunnelName);\n  }\n\n  const devComposePath = path.join(cwd, \"docker-compose.dev.yml\");\n  await fs.writeFile(\n    devComposePath,\n    yaml.dump(compose, { indent: 2, lineWidth: -1 })\n  );\n  await createEnvTemplate(cwd, services, \"dev\");\n}\n\nasync function createTunnelService(projectDir: string, serviceName: string) {\n  const tunnelDir = path.join(projectDir, `${serviceName}-tunnel`);\n  await fs.ensureDir(tunnelDir);\n\n  const dockerfile = `FROM alpine:latest\n\nRUN apk add --no-cache openssh-client\n\nCOPY tunnel.sh /tunnel.sh\nRUN chmod +x /tunnel.sh\n\nCMD [\"/tunnel.sh\"]\n`;\n\n  const tunnelScript = `#!/bin/sh\n\nSSH_KEY=\"/ssh/${serviceName}.pem\"\nREMOTE_HOST=\\${REMOTE_HOST}\nREMOTE_PORT=\\${REMOTE_PORT:-${getDefaultPort(serviceName)}}\nLOCAL_PORT=\\${LOCAL_PORT:-${getDefaultPort(serviceName)}}\n\nchmod 600 $SSH_KEY\n\necho \"Starting SSH tunnel for ${serviceName}...\"\necho \"Remote: $REMOTE_HOST:$REMOTE_PORT -> Local: $LOCAL_PORT\"\n\nssh -i $SSH_KEY \\\\\n    -N -L 0.0.0.0:$LOCAL_PORT:localhost:$REMOTE_PORT \\\\\n    -o StrictHostKeyChecking=no \\\\\n    -o ServerAliveInterval=60 \\\\\n    $REMOTE_HOST\n`;\n\n  await fs.writeFile(path.join(tunnelDir, \"Dockerfile\"), dockerfile);\n  await fs.writeFile(path.join(tunnelDir, \"tunnel.sh\"), tunnelScript);\n}\n\nasync function createEnvTemplate(\n  projectDir: string,\n  services: DockerService[],\n  env: \"dev\" | \"prod\"\n) {\n  const envPath = path.join(projectDir, \".env.example\");\n\n  let content = `NODE_ENV=${\n    env === \"prod\" ? \"production\" : \"development\"\n  }\\nPORT=3000\\n`;\n\n  if (services.length > 0) {\n    content += `\\n`;\n    for (const service of services) {\n      const vars = getEnvVars(service.name);\n      content += vars.join(\"\\n\") + \"\\n\\n\";\n    }\n  }\n\n  await fs.writeFile(envPath, content);\n}\n\nfunction getServiceConfig(serviceName: string) {\n  const configs: Record<string, any> = {\n    postgres: {\n      service: {\n        image: \"postgres:15-alpine\",\n        environment: [\n          \"POSTGRES_USER=${DB_USER}\",\n          \"POSTGRES_PASSWORD=${DB_PASSWORD}\",\n          \"POSTGRES_DB=${DB_NAME}\",\n        ],\n        volumes: [\"postgres_data:/var/lib/postgresql/data\"],\n        networks: [\"web\"],\n      },\n      volume: { name: \"postgres_data\" },\n    },\n    mysql: {\n      service: {\n        image: \"mysql:8\",\n        environment: [\n          \"MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}\",\n          \"MYSQL_DATABASE=${DB_NAME}\",\n          \"MYSQL_USER=${DB_USER}\",\n          \"MYSQL_PASSWORD=${DB_PASSWORD}\",\n        ],\n        volumes: [\"mysql_data:/var/lib/mysql\"],\n        networks: [\"web\"],\n      },\n      volume: { name: \"mysql_data\" },\n    },\n    redis: {\n      service: {\n        image: \"redis:7-alpine\",\n        volumes: [\"redis_data:/data\"],\n        networks: [\"web\"],\n      },\n      volume: { name: \"redis_data\" },\n    },\n    mongodb: {\n      service: {\n        image: \"mongo:6\",\n        environment: [\n          \"MONGO_INITDB_ROOT_USERNAME=${DB_USER}\",\n          \"MONGO_INITDB_ROOT_PASSWORD=${DB_PASSWORD}\",\n        ],\n        volumes: [\"mongo_data:/data/db\"],\n        networks: [\"web\"],\n      },\n      volume: { name: \"mongo_data\" },\n    },\n  };\n\n  return configs[serviceName];\n}\n\nfunction getEnvVars(serviceName: string): string[] {\n  const vars: Record<string, string[]> = {\n    postgres: [\n      \"DB_HOST=postgres\",\n      \"DB_PORT=5432\",\n      \"DB_USER=myuser\",\n      \"DB_PASSWORD=mypassword\",\n      \"DB_NAME=mydb\",\n    ],\n    mysql: [\n      \"DB_HOST=mysql\",\n      \"DB_PORT=3306\",\n      \"DB_USER=myuser\",\n      \"DB_PASSWORD=mypassword\",\n      \"DB_NAME=mydb\",\n      \"DB_ROOT_PASSWORD=rootpassword\",\n    ],\n    redis: [\"REDIS_HOST=redis\", \"REDIS_PORT=6379\"],\n    mongodb: [\n      \"MONGO_HOST=mongodb\",\n      \"MONGO_PORT=27017\",\n      \"MONGO_USER=myuser\",\n      \"MONGO_PASSWORD=mypassword\",\n    ],\n  };\n\n  return vars[serviceName] || [];\n}\n\nfunction getDefaultPort(service: string): number {\n  const ports: Record<string, number> = {\n    postgres: 5432,\n    mysql: 3306,\n    redis: 6379,\n    mongodb: 27017,\n  };\n  return ports[service] || 3000;\n}\n\nfunction printNextSteps(\n  projectName: string,\n  env: string,\n  services: DockerService[]\n) {\n  console.log(`\\n\u2705 Done! Next steps:\\n`);\n\n  if (env === \"prod\") {\n    console.log(`  # Edit .env with your settings`);\n    console.log(`  docker-compose up -d`);\n    console.log(`  # Access at https://localhost\\n`);\n  } else {\n    console.log(`  # Edit .env with your settings`);\n    if (services.some((s) => s.needsTunnel)) {\n      console.log(`  # Add SSH keys: {service}.pem`);\n    }\n    console.log(`  docker-compose -f docker-compose.dev.yml up -d\\n`);\n  }\n}\n"],
  "mappings": "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",
  "names": ["esbuild", "fs", "esbuild", "fs", "path", "path", "Module", "path", "context", "path", "Module", "result", "context", "path", "path", "parseSync", "stringifyType", "stringifyType", "transform", "path", "context", "parseSync", "hasComponentDecorator", "extractMethods", "extractMethodParams", "extractReturnType", "stringifyType", "parseSync", "extractServiceInfo", "generateStubCode", "hasInjectableDecorator", "extractMethods", "extractMethodParams", "extractReturnType", "stringifyType", "path", "parseSync", "fs", "path", "fs", "copyFile", "entryPoints", "resolve", "fs", "path", "ts", "fs", "path", "path", "path", "fs", "ts", "createModule", "path", "path", "fs", "path", "path"]
}
